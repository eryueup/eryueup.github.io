[{"title":"Echarts图表工具","url":"/2021/05/12/Echarts%E5%9B%BE%E8%A1%A8%E5%B7%A5%E5%85%B7/","content":"教程教程\n入门\nECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。ECharts 遵循 Apache-2.0 开源协议，免费商用。ECharts 兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）及兼容多种设备，可随时随地任性展示。\n\n需要的知识：HTML  JavaScript \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;第一个 ECharts 实例&lt;/title&gt;    &lt;!-- 引入 echarts.js --&gt;    &lt;script src=&quot;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));         // 指定图表的配置项和数据        var option = &#123;            title: &#123;                text: &#x27;第一个 ECharts 实例&#x27;            &#125;,            tooltip: &#123;&#125;,            legend: &#123;                data:[&#x27;销量&#x27;]            &#125;,            xAxis: &#123;                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]            &#125;,            yAxis: &#123;&#125;,            series: [&#123;                name: &#x27;销量&#x27;,                type: &#x27;bar&#x27;,                data: [5, 20, 36, 10, 10, 20]            &#125;]        &#125;;         // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n示例结果：\nECharts特性\n丰富的可视化类型: 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。\n多种数据格式无需转换直接使用: 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，此外还支持输入 TypedArray 格式的数据。\n千万数据的前端展现: 通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量。移动端优化: 针对移动端交互做了细致的优化，例如移动端小屏上适于用手指在坐标系中进行缩放、平移。 PC 端也可以用鼠标在图中进行缩放（用鼠标滚轮）、平移等。\n多渲染方案，跨平台使用: 支持以 Canvas、SVG（4.0+）、VML 的形式渲染图表。\n深度的交互式数据探索: 提供了 图例、视觉映射、数据区域缩放、tooltip、数据刷选等开箱即用的交互组件，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。\n多维数据的支持以及丰富的视觉编码手段: 对于传统的散点图等，传入的数据也可以是多个维度的。\n动态数据: 数据的改变驱动图表展现的改变。\n绚丽的特效: 针对线数据，点数据等地理数据的可视化提供了吸引眼球的特效。\n通过 GL 实现更多更强大绚丽的三维可视化: 在 VR，大屏场景里实现三维的可视化效果。\n无障碍访问（4.0+）: 支持自动根据图表配置项智能生成描述，使得盲人可以在朗读设备的帮助下了解图表内容，让图表可以被更多人群访问！\n\nECharts 安装和使用本地使用\n\n直接下载 echarts.min.js 并用 &lt;script&gt; 标签引入：下载地址：https://www.echartsjs.com/zh/download.html。完全版：echarts/dist/echarts.js，体积最大，包含所有的图表和组件，所包含内容参见：echarts/echarts.all.js。常用版：echarts/dist/echarts.common.js，体积适中，包含常见的图表和组件，所包含内容参见：echarts/echarts.common.js。精简版：echarts/dist/echarts.simple.js，体积较小，仅包含最常用的图表和组件，所包含内容参见：echarts/echarts.simple.js。CDN使用\n\nStaticfile CDN（国内） : https://cdn.staticfile.org/echarts/4.3.0/echarts.min.jsjsDelivr：https://cdn.jsdelivr.net/npm/echarts@4.3.0/dist/echarts.min.js。cdnjs : https://cdnjs.cloudflare.com/ajax/libs/echarts/4.3.0/echarts.min.js\n&lt;!-- 引入 echarts.js --&gt;&lt;script src=&quot;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js&quot;&gt;&lt;/script&gt;\nNPM方法\nECharts 快速使用创建 HTML 页面:创建一个 HTML 页面，引入 echarts.min.js：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;!-- 引入 ECharts 文件 --&gt;    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;\n为 ECharts 准备一个具备高宽的 DOM 容器\n&lt;body&gt;    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;\n 设置配置信息:ECharts 库使用 json 格式来配置。\necharts.init(document.getElementById(&#x27;main&#x27;)).setOption(option);\n这里 option 表示使用 json 数据格式的配置来绘制图表。步骤如下：\n*标题*为图表配置标题：\ntitle: &#123;    text: &#x27;第一个 ECharts 实例&#x27;&#125;\n\n暂放\n","categories":["study"],"tags":["JavaScript"]},{"title":"Java基础","url":"/2021/08/25/Java%E5%9F%BA%E7%A1%80/","content":"基础前言\nJava是面向对象、跨平台的高级编程语言\nJVM：Java虚拟机，JVM是实现Java程序跨平台的基石，本身并不支持跨平台。Java程序一次编译,到处运行\n\nJDK、JRE、JVM\n\nJVM: Java虚拟机,是专门用来运行Java程序的,但是不能单独安装\n\nJRE: Java运行环境,包含JVM和核心类库\n\nJDK: Java程序开发工具包,包含JRE和开发工具\n\n\n\n\n三者关系： JDK &gt; JRE &gt; JVM\n\n配置环境变量# add system env variables# JAVA_HOME: Java installation directory# PATH: %JAVA_HOME%\\bin# java -version\n\n快速入门\nJava程序开发步骤：\n*.java源文件---javac编译---&gt;*.class字节码文件---java执行---&gt;JVM\n\n# Moments of fun# javac A.java# java A\n\n进制\n进制\n\n\n十进制、二进制、八进制、十六进制\n\n\n进制转换\n\n\n\n①十进制–&gt;二进制\n整数：”除2取余，逆序排列”。截至余数为0，10(10)-&gt; 1010(2)\n小数：”乘2取整，顺序排列”。截至乘积小数位为0，0.125(10) -&gt; 0.001(2) \n负数：-42 -&gt; 正数42(10) -&gt; 00101010(2) -&gt; 取反加1-&gt;11010101(2) + 1(2) -&gt; 11010110(2)\n\n②二进制–&gt;十进制\n整数、小数举例：11.11(2) -&gt; 3+2^(-1)^+2^(-2)^ -&gt; 3.75(10)\n负数：11010110(2) -42 -&gt; 减1取反 00101010(2) -&gt; -42(10)\n\n\n\n常量\n\n整型常量：10\n\n浮点型常量：0.5\n\n字符型常量：’a’ ，&#39;&#39;，’你’。&#39;&lt;Nothing&gt;&#39;,&#39;你好&#39;是不合法的。此处表示空格与空的区别。\n\n布尔型常量：true false\n\n字符串常量：”a”，””，”  “，”ab”，”你好”\n\n空常量：null\n\n\n\n变量\n变量概念: 在程序的执行过程中,其值可以在一定范围内发生改变的量。开辟的内存空间\n\n\n\n基本数据类型：包括 整型 、 浮点型 、 字符型 、 布尔型 。\n\n引用数据类型：包括 类 、 数组 、 接口 。\n\n\n\n\n\n整数类型是 int 、浮点类型是 double \n\n标识符\n自定义的类、方法、属性等名称\n\n\n命名规则\n\n\n标识符可以包含 英文字母(区分大小写) 、 0-9 、 $ 和 _\n标识符不能以数字开头\n标识符不能是关键字\n\n\n命名规范\n\n\n类名规范：大驼峰式\n方法名规范：小驼峰式\n变量名规范：小驼峰式\n\n数据类型转换\n自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。\n\n\nbyte、short、char–&gt;int–&gt;long–&gt;float–&gt;double\nbyte、short、char 运算时直接提升为 int 。\n\n\n强制转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。\n\nbyte b1 = 3;byte b2 = 4;byte b3 = b1 + b2;// Compile Error: byte--&gt;int\n\n运算符\n\n算数运算符+ - * / % +=...++ --\n赋值运算符+= -= *= /= %=\n自增自减运算符++ --\n关系运算符== != &gt;= &lt;= &gt; &lt;\n逻辑运算符&amp; | ! ^，短路与或&amp;&amp; ||与&amp; |结果一致，但可以提高效率，&amp;&amp;左侧fasle结束，||左侧true结束\n三元运算符关系表达式 ? 表达式1 : 表达式2\n\n\n\n\n%:奇偶、取各个位的数：num%10取个位数，num/10%10取十位数\n+=,-=,/=,*=,%= 运算结果的数据类型和左侧变量的数据类型不一致,隐藏强制类型转换\n整数常量只要不超出所赋值的整数变量的取值范围,可以直接赋值,内部隐藏强制类型转换\n\n\n流程控制\n顺序结构\n选择/分支结构：if、switch\n循环结构：for、while、do-while\n\n\nfor、while：先判断后执行；for变量一般是临时、while变量一般是外部\nwhile、do-while：do-while先执行后判断\n\npublic class IFDemo &#123;    public static void main(String[] args) &#123;        int a = 1;        // if        if (a &gt; 1) System.out.println(true);        if (a &gt; 1) &#123;            System.out.println(true);        &#125; else if (a == 1) &#123;            System.out.println(1);        &#125; else &#123;            System.out.println(false);        &#125;        // switch        // switch后面()中的表达式的数据类型,只能是以下几种类型:        //      基本类型: byte/short/char/int 都可以        //      引用类型: String或者枚举        // case 后面只能写常量,而且常量值不能重复        switch (a) &#123;            case 1:                System.out.println(1);                break;            default:                break;        &#125;    &#125;&#125;\n\n\n\n循环\nfor\nwhile\ndo-while\n\n循环跳转：\nbreak（结束循环；结束整个switch语句）continue（结束本次循环继续下次循环：continue的循环体中的语句本次不会执行）\n\n循环嵌套: \nfor(初始化表达式1;布尔表达式2;步进表达式7)&#123;//外层循环 for(初始化表达式3;布尔表达式4;步进表达式6) &#123;//内层循环      内层循环的循环体5;  &#125;  &#125;其它语句;\n\n随机数java.util.Random：左闭右开\n随机int：nextInt()[0,99]: nextInt(100)    [1,5]: nextInt(5) + 1[66,178]: nextInt(113) + 66\n\n数组\n特点：引用类型；可存储多个数据；可存储的数据类型需要一致；数组一旦创建长度不可变。\n定义格式：int[] a; int a[]\n初始化格式\n\n动态初始化（指定长度）int[] c = new int[3];标准格式静态初始化(指定数组元素)  int[] c = new int[]&#123;1,2,3&#125;;简化格式静态初始化(指定数组元素) int[] c = &#123;1,2,3&#125;;\n\n\n 数组元素有默认值:\n\n1.整数:       02.小数:       0.03.字符:       空白字符4.布尔:       false\n\n\n两个数组指向同一内存地址\n\nint[] a = &#123;1,2,3&#125;;int[] b = a;// 操作任何一个改变的是同一个数组\n\nJava的内存分配：\n\n1.方法区: 存储可以运行的class文件。2.方法栈: 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。存储局部变量。3.堆内存: 存储对象或者数组，new来创建的，都存储在堆内存。4.寄存器: 给CPU使用，和我们开发无关                              不关心5.本地方法栈: JVM在使用操作系统功能的时候使用，和我们开发无关。        不关心\n\n\n方法\n形参和实参\n\n\n形参：方法定义的形式参数\n实参：方法调用的实际参数（含变量）\n\n方法参数是基本类型: 形式参数的改变,不会影响实际参数(调用时以复制数据形式)方法参数是引用类型: 形式参数的改变,会影响实际参数,如修改数组或者集合中的某个值(调用时以地址形式，内存地址不会改变)\npublic class ParameterDemo &#123;    public static void main(String[] args) &#123;        int a = 10;        System.out.println(a);        change(a);        System.out.println(a);        System.out.println(&quot;======&quot;);        int[] arr = &#123;2&#125;;        System.out.println(arr[0]);        change(arr);        System.out.println(arr[0]);    &#125;    private static void change(int[] arr) &#123;        System.out.println(arr[0]);        arr[0] *= arr[0];        System.out.println(arr[0]);    &#125;    private static void change(int a) &#123;        System.out.println(a);        a *= 10;        System.out.println(a);    &#125;&#125;\n\n\n\n\n方法重载\n\n\n有关要素：方法名称相同、参数类型不同(*参数个数相同但类型位置不同)、参数个数不同有关\n无关要素：与参数名称、返回值类型、方法修饰符无关\n\n重载形式参数为基本数据时，未重载byte会去调用int、未long会double\n进阶day01_类和面向对象面向对象和面向过程编程思想\n面向过程编程思想\n\n\n强调的是过程,必须清楚每一个步骤,然后按照步骤一步一步去实现\n\n\n面向对象编程思想\n\n\n强调的是对象, 通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。\n\n类\n概述\n\n\n类是用来描述一类具有共同属性和行为事物的统称。所以其实类在客观世界里是不存在的，是抽象的，只是用来描述数据信息的。\n\n\n组成\n\n\n属性：该事物的状态信息\n行为：该事物能做什么\n\n对象\n概念\n\n\n对象是一个类的实例，具体存在的（如对属性进行赋值、行为进行操作），并且具备该类事物的属性和行为\n\n类和对象的关系\n类是对一类具有共同属性和行为的事物的统称,是抽象的\n对象是一类事物的具体实例,可实际操作,真实存在的实体,是具体的\n类是对象的抽象,对象是类的实体（实例）\n\n类的创建\n类的组成\n\n\n属性（成员变量）、行为（成员方法）\n\n\n类的创建\n\n// 定义一个类// 类里面:属性(成员变量),行为(成员方法)public class 类名 &#123;\t// 定义成员变量    数据类型 变量名1;    数据类型 变量名2;    ...            // 定义成员方法    方法;&#125;\n\n对象的创建与使用\n对象的创建\n\n类名 对象名 = new 类名();\n\n\n对象的使用\n\n\n.运算符\n\n成员变量默认值\n整数类型: 默认值是0浮点类型: 默认值是0.0布尔类型: 默认值是false字符类型: 默认值是不可见字符 ‘\\u0000’引用类型: 默认值是null\n\n对象内存图\n单个对象内存图\n\n\n\n只要创建对象,就会在堆区开辟一块空间(new会在堆区开辟一块新的空间存放成员变量(有默认值)和成员方法地址值)\n只要调用方法,就会在栈区开辟一块空间,用来执行该方法\n\n\n多个对象内存图\n\n\n\n多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自对象的内存区域中，成员方法多个对象共用一份（方法区中，使用时加载入栈）\n凡是new就会重新在堆区开辟一块新空间\n对象和对象之间的关系是相互独立的\n\n\n多个变量指向相同对象内存图【理解】\n\n\n\n当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）\n只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。\n引用类型传递的是地址值\n\n成员变量和局部变量的区别【理解】\n类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）\n内存中位置不同：成员变量（堆内存）局部变量（栈内存）\n生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，随着方法的调用完毕而消失）\n初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\n\n封装\nprivate关键字\n\n\nprivate修饰的成员变量或者成员方法,只能在本类中访问\n\n封装概述\n\n是面向对象三大特征之一（封装，继承，多态）是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的\n\n为什么对属性进行封装\n\n如果通过对象名直接访问成员变量的方式来对属性赋值,会存在数据安全隐患；不让外界直接访问成员变量(也就是要对属性进行封装)，提供公共的访问方法，进行数据校验保证数据安全\n\n对成员变量封装的步骤(原则)\n\n1.使用private关键字修饰成员变量，将类的某些信息隐藏在类的内部，不允许外部程序直接访问2.提供公共的访问方法:给成员变量赋值的公共方法(set方法)获取成员变量值的公共方法(get方法)\n\n封装优点\n\n通过类提供的公共方法来控制对成员变量的操作，提高了代码的安全性把代码用方法进行封装，提高了代码的复用性\n\n\nset和get方法\n\n\n由于属性使用了private关键字修饰,在其他类中无法直接访问,所以得提供公共的访问方法,叫做set和get方法,用public修饰\n\n\nthis关键字\n\n\nthis关键字其主要作用是区分同名的局部变量和成员变量\n方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\n\n\n\nthis可以调用成员变量、成员方法、构造方法（解决代码冗余问题）\n\n构造方法\n概述\n\n\n完成对象的创建和对象数据的初始化\n\n\n定义\n\n// 空参构造方法修饰符 类名()&#123;    &#125;// 有参构造方法修饰符 类名(参数列表)&#123;\t// 方法体&#125;// demopublic class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;        // 如果创建了有参构造方法，不会默认提供无参构造方法    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n\n特点\n\n\n构造方法的方法名和类名一致构造没有返回值如果没有定义构造方法，系统将给出一个默认的无参数构造方法;如果定义了构造方法，系统将不再提供默认的构造方法构造方法可以重载构造方法只可以赋值一次，调用即创建新对象，可以使用set赋值\n\n标准类制作\n概述\n\n\nJavaBean 是 Java语言编写类的一种标准规范。符合JavaBean 的类，要求类必须是公共的，属性使用private修饰,并且具有无参数的构造方法，提供用来操作成员变量的set 和get 方法。\n\npublic class ClassName&#123;  //成员变量  private  //构造方法  //无参构造方法【必须】  //满参构造方法【建议】  //getXxx()  //setXxx()  //成员方法\t&#125;\n\nAPIday02_静态、继承、模板设计模式、抽象类、final匿名对象\n概述\n\n\n指没有名称的对象\n\n\n特点\n\n\n匿名对象只能使用一次\n\n\n使用场景\n\n\n当某个类的对象只需要使用一次的时候,就可以使用该类的匿名对象例如:方法的参数,方法的返回值\n\n继承\n概述\n\n\n在java中指的是“一个类”可以“继承自”“另一个类”。 “被继承的类”叫做: 父类/超类/基类，”继承其他类的类”叫做:子类。继承后，“子类”中就“拥有”了“父类”中所有的成员(成员变量、成员方法)。 “子类就不需要再定义了”\n\n\n格式\n\nclass 父类 &#123;\t...&#125;class 子类 extends 父类 &#123;\t...&#125;\n\n\n\n\n优点\n\n\n提高代码的复用性（减少代码冗余，相同代码重复利用）[将一些共性的属性,行为抽取到一个父类中]。使类与类之间产生了关系(多态）。\n\n\n特点\n\n\n类只支持单继承\n一个类只有一个父类，但可以有多个子类\n支持多层继承\n\n继承后成员访问规则\n构造方法不能被继承\n父类的“私有成员”可以被子类继承，但子类不能直接访问。\n当通过“子类”访问非私有成员时，先在子类中找，如果找到就使用子类的，找不到就继续去“父类”中找。\n\n继承父类**成员是全继承**(包括静态属性和静态方法【子类静态方法声明可与父类相同，但并非重写，添加Override会编译报错，静态方法与类绑定，并非与对象绑定，亦不是多态】)，访问成员只需要考虑**私有或者非私有**\n方法重写\n概述\n\n\n返回值类型，方法名和参数列表都相同。声明不变，重新实现。\n\n\n注意事项\n\n\n方法重写是发生在子父类之间的关系。\n子类方法重写父类方法，返回值类型、方法名和参数列表都要一模一样。\n子类方法重写父类方法，必须要保证权限大于等于父类权限。访问权限从大到小: public protected (默认) private\n使用@Override注解，检验是否重写成功，重写注解校验！\n\nthis和superthis关键字的三种用法:     this可以访问本类的成员变量: this.成员变量         一般用来区分同名的成员变量和局部变量     this可以访问本类的成员方法: this.成员方法名(实参);        this可以访问本类的构造方法:          空参构造: this();          有参构造: this(实参);              注意:                   1.只能在本类的构造方法中使用this调用其他构造方法                   2.在本类的构造方法中使用this调用其他构造方法,必须放在该构造方法的第一行,否则会报错                   3.两个构造方法不能使用this同时相互调用                       super关键字的三种用法:     super可以访问父类的成员变量: super.成员变量         一般用来区分父子类中同名的成员变量     super可以访问父类的成员方法: super.成员方法(实参);   一般用来在子类中访问父类的成员方法     super可以访问父类的构造方法:          空参构造: super();          有参构造: super(实参);              注意:                 1.子类的构造方法默认会调用父类的空参构造方法                 2.super访问父类的构造方法,可以用来初始化从父类继承过来的属性                 3.在子类的构造方法中,使用super调用父类的构造方法,必须放在子类构造方法的第一行 *super注意事项：     super访问成员变量和成员方法: 优先去父类中找,如果有就直接使用,如果没有就去爷爷类中找,如果有,就用,依次类推...     子类的构造方法默认会调用父类的空参构造方法,如果父类中的没有空参构造方法,只定义了有参构造方法,会编译报错     子类构造方法中使用super调用父类的构造方法,是为了在创建子类对象的时候,初始化从父类继承过来的属性\n\n继承体系对象的内存图\n概述\n\n\n继承体系内存图原理—父类空间优先于子类对象产生。在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。\n\n\n抽象类\n概述\n\n\n使用abstract关键字修饰的类就是抽象类\n\n\n格式\n\n修饰符 abstract class 类名&#123;    // 抽象类可以拥有的成员    // 成员变量    // 构造方法    // 成员方法    // 抽象方法&#125;// 例如：public可以省略public abstract class Person&#123;&#125;\n\n\n\n\n特点\n\n\n抽象类不可以创建对象，主要用于子类继承\n抽象类可以有构造方法，子类继承时可调用构造方法用于初始化\n抽象类中可以没有抽象方法，抽象方法必须定义在抽象类中\n子类继承抽象类后，必须重写抽象类中的所有抽象方法，否则子类必须也是一个抽象类\n\n抽象方法\n概述\n\n\n没有方法体,使用abstract修饰的方法就是抽象方法\n\n\n格式\n\n修饰符 abstract 返回值类型 方法名(形参列表);例如:\tpublic abstract void work();\n\n\n使用场景与作用\n\n\n抽象方法的使用场景:如果父类中某个方法,所有子类都有不同的实现,那么就可以把该方法定义为抽象方法\n抽象方法的作用: 强制要求子类重写\n\n模板设计模式\n概述\n\n\n针对某些情况,在父类中指定一个模板,然后根据具体情况,在子类中灵活的具体实现该模板\n\n\n实现步骤\n\n\n1、定义抽象父类作为模板2、在父类中定义”模板方法”— 已实现方法(通用模板)+抽象方法(填充模板)3、子类继承父类,重写抽象方法(填充父类的模板)4、测试类:创建子类对象，通过子类调用父类的“实现的方法”+ “子类重写后的方法”\n\nfinal关键字\n概述\n\n\n不可改变。可以用于修饰类、方法和变量。\n\n\n类：被修饰的类，不能被继承。方法：被修饰的方法，不能被重写。变量：被修饰的变量（变量名全大写），就只能赋值一次,不能被重新赋值。\n\n例如public final class String 、public final class Math 、public final class Scanner\n\nfinal修饰变量\n局部变量\n\n基本类型：只能赋值一次，不能再更改。\n引用类型：只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改\n\n成员变量\n\n成员变量涉及到初始化的问题，初始化方式有两种\n\n\n\n// 1、显示初始化；public class FinalVariable &#123;    final int NUM1 = 10;&#125;// 2、构造方法初始化。public class FinalVariable &#123;    final int NUM2;    // 所有的构造方法都要涵盖对final修饰的成员变量初始化    public FinalVariable()&#123;        this.NUM2 = 10;    &#125;    public FinalVariable(int NUM2)&#123;        this.NUM2 = NUM2;    &#125;&#125;\n\nstatic关键字\n概述\n\n\nstatic是一个静态修饰符关键字,可以修饰成员变量和成员方法以及代码块。\n\n\n使用\n\nstatic修饰成员变量\n\n类名.静态成员变量名，被static修饰的变量会被该类的所有对象共享\n\nstatic修饰成员方法\n\n类名.方法名(实参);\n\n\n注意事项\n\n\n静态方法中不能出现this关键字\n静态方法中只能直接访问静态成员变量和静态成员方法\n非静态方法中可以直接访问一切成员变量和成员方法\n\n\nday03 _接口、多态、内部类接口\n概述\n\n\n接口是Java语言中的一种引用类型，是方法的”集合”，所以接口的内部主要就是定义方法\n\n\n定义\n\n\n接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。\n\npublic interface 接口名称 &#123;    // 常量(jdk7及其以前)    // 抽象方法(jdk7及其以前)    // 默认方法(jdk8)    // 静态方法(jdk8)    // 私有方法(jdk9)&#125;\n\n引用数据类型：数组，类，接口。\n\n特点\n\n\n接口不能创建对象，需要实现类（子类）实现接口，并重写所有抽象方法，否则为抽象类\n\npublic interface IA &#123;    /*    接口成员     */    // jdk7及以前====：常量、抽象方法    // 常量:使用public static final修饰，可省略    int NUM = 10;    // 抽象方法：使用public abstract修饰，可省略    void m1();    // jdk8====：默认方法、静态方法    // 默认方法：使用public default修饰，public可省略    default void m2() &#123;        System.out.println(&quot;default m...&quot;);    &#125;    // 静态方法: 使用public static修饰，public可省略    static void m3() &#123;        System.out.println(&quot;static m...&quot;);    &#125;    // jdk9====：私有方法    // 私有静态方法    private static void m4() &#123;        System.out.println(&quot;private static m...&quot;);    &#125;    // 私有非静态方法    private void m5() &#123;        System.out.println(&quot;private 非静态方法&quot;);    &#125;&#125;\n\n接口中成员访问特点public interface IA &#123;    // 常量    int NUM = 10;    // 抽象方法    void m1();    // 默认方法    default void m2() &#123;        // m4();        System.out.println(&quot;default m...&quot;);    &#125;    // 静态方法    static void m3() &#123;        // m5();        System.out.println(&quot;static m...&quot;);    &#125;    // 私有方法:供本接口调用    private void m4() &#123;        System.out.println(&quot;private m...&quot;);    &#125;    private static void m5() &#123;        System.out.println(&quot;private static m...&quot;);    &#125;&#125;public class Imp implements IA &#123;    @Override    public void m1() &#123;        System.out.println(&quot;Imp IA abstract m...&quot;);    &#125;    @Override    public void m2() &#123;        System.out.println(&quot;Imp IA default m...&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*        常量：**主要**供接口名直接访问，也可以被以实现类(抽象类和子类接口或者实现类)形式访问        抽象方法：供实现类重写        默认方法：供实现类重写或实现类对象调用。default标识接口方法体        静态方法：**仅仅**供接口直接调用，这一点与类不同(详细见继承)        私有方法：仅仅供本接口调用         */        System.out.println(IA.NUM);        Imp imp = new Imp();        imp.m1();        imp.m2();        IA.m3();    &#125;&#125;\n\n多实现时的几种冲突\n公有静态常量的冲突:实现类不继承冲突的常量公有抽象方法的冲突:实现类只需要重写一个公有默认方法的冲突:实现类必须重写一次最终版本公有静态方法的冲突:静态方法是直接属于接口的,不能被继承,所以不存在冲突私有方法的冲突:私有方法只能在本接口中直接使用,不存在冲突\n\n接口与接口之间的关系\n概述\n\n\n接口可以“继承”自另一个“接口”，而且可以“多继承”。\n\ninterface IA&#123;&#125;interface IB&#123;&#125;interface IC extends IA,IB&#123;//是“继承”，而且可以“多继承”&#125;\n\n\n接口多继承时的冲突情况\n\n\n公有静态常量的冲突:子接口无法继承父接口中冲突的常量公有抽象方法的冲突:子接口只会继承一个有冲突的抽象方法公有默认方法的冲突:子接口中必须重写一次有冲突的默认方法(注意要加default)公有静态方法和私有方法的冲突:不冲突,因为静态方法是直接属于接口的,只能使用本接口直接访问,而私有方法只能在接口中访问,也没有冲突\n面试题:     实现类重写接口中的默认方法,不需要加default        子接口重写父接口中的默认方法,必须加default\n\n实现类继承父类又实现接口时的冲突\n公有静态常量的冲突:子类无法继承有冲突的常量公有抽象方法的冲突:子类必须重写一次有冲突的抽象方法公有默认方法的冲突:优先访问父类的(父类中此默认方法无default修饰)公有静态方法的冲突:只会访问父类的静态方法私有方法的冲突: 不存在冲突，无法直接访问\n\n*Note：继承和实现\n继承\n\n\n所有类成员变量和成员方法都可以被继承(接口不是类)父类中的成员一定是所有子类共有的\n\n\n实现\n\n\n实现类只能继承抽象方法、默认方法、（常量也可以，一般使用接口直接访问）接口直接访问常量、静态方法、私有方法（接口中）\n\n多态\n概述\n\n\n多态是继封装、继承之后，面向对象的第三大特性。是指同一行为，对于不同的对象具有多个不同表现形式。\n\n\n前提条件\n\n\n1继承或者实现【二选一】2父类引用指向子类对象\\接口引用指向实现类对象【格式体现】3方法的重写【意义体现：不重写，无意义】\n\n多态时访问成员的特点\n成员变量:编译看父类,运行看父类(编译看左边,运行看左边)成员方法:   非静态方法:编译看父类,运行看子类(编译看左边,运行看右边)   静态方法: 编译看父类,运行看父类(编译看左边,运行看左边)结论:除了非静态方法是编译看父类,运行看子类,其余都是看父类\n另外，private修饰的成员不可跨类。static修饰的成员不具有多态（继承处笔记有说明）\n\n多态的几种表现形式\n普通父类多态：继承一个类\n抽象父类多态：继承一个抽象类\n父接口多态：实现接口\n\n多态的几种应用场景\n作为变量：变量多态–意义不大【父类类型的变量指向子类类型的对象】\n作为形参：形参多态–常用【方法形参类型为父类类型】\n作为返回值：返回值多态–常用【返回值为父类类型】\n\n示例\nDog extends Animal; // 略写Animal anl = new Dog(); // 变量多态public void show(Animal anl)&#123;    anl.eat()；&#125;// 形参多态public Animal show()&#123;    return new Dog();&#125;// 返回值多态\n\n多态的好处和弊端\n好处:提高代码的复用性弊端:无法访问子类独有的方法或者成员变量【此弊端可以使用向下转型解决】,因为多态成员访问的特点是,编译看父类，以父类引用调用子类独有编译报错\n\n引用类型转换\n向上转型:可形成多态\n向下转型:可解决多态弊端\n\n注意: 1.向下转型的时候:右边父类类型的变量一定要指向要转型的子类类型的对象 2.不管是向上转型还是向下转型,一定满足父子类关系或者实现关系\n// 使用向下转型解决弊端public class Animal &#123;    public void eat() &#123;        System.out.println(&quot;eat&quot;);    &#125;&#125;class Cat extends Animal &#123;    int a = 1;    @Override    public void eat() &#123;        System.out.println(&quot;eat fish&quot;);    &#125;    public void play() &#123;        System.out.println(&quot;cat playing&quot;);    &#125;&#125;class UpOrDownT &#123;    public static void main(String[] args) &#123;        // up casting,default to execute        Animal anl = new Cat();        // anl.play(); // compile err        anl.eat();        // down casting        Cat cat = (Cat) anl;        cat.eat();        cat.play();        System.out.println(cat.a);                // compile normal,runtime err        Animal anl2 = new Animal();        // java.lang.ClassCastException: Animal cannot be cast to Cat        Cat cat2 = (Cat) anl2; //anl2, parent class reference does not point to child class    &#125;&#125;\n\n\n\n\ninstanceof关键字\n\nif (anl instanceof Dog)&#123;\t\tDog  d = (Dog)anl;&#125;\n\n\n解决多态弊端和多态的综合示例代码\n\nclass Animal &#123;    public void eat() &#123;        System.out.println(&quot;吃东西...&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗吃骨头...&quot;);    &#125;    // 特有的功能    public void lookHome() &#123;        System.out.println(&quot;狗在看家...&quot;);    &#125;&#125;class Cat extends Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;猫吃鱼...&quot;);    &#125;    // 特有的功能    public void catchMouse() &#123;        System.out.println(&quot;猫抓老鼠...&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        m(new Dog());    &#125;    public static void m(Animal anl) &#123;        anl.eat();        if (anl instanceof Dog) &#123;            ((Dog) anl).lookHome();        &#125; else if (anl instanceof Cat) &#123;            ((Cat) anl).catchMouse();        &#125;    &#125;&#125;\n\n内部类\n格式\n\nclass 外部类A &#123;    class 内部类B&#123;    &#125;&#125;// new A().new B();\n\n\n访问特点\n\n\n内部类可以直接访问外部类的成员，包括私有成员。外部类要访问内部类的成员，必须要创建内部类的对象。\n\n*外部类加载进入内存不会加载内部类,所以有如上规则.另只有静态内部类可以存在静态成员,非静态内部类不可以存在静态成员\n*方法外部定义的内部类可以以public修饰，可有多个public修饰的内部类;内部类可以访问外部private成员\n*观察Java编译器编译后的.class文件可以发现，Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class\nclass A&#123;    static class B&#123;        static void m()&#123;&#125;    &#125;&#125;// A.B.m();\n*Note:Java中四种内部类\n四种内部类：成员内部类、局部内部类(不可添加类修饰符)、静态内部类、匿名内部类\npublic class InnerClass &#123;    // member innert class    public class Car &#123;        private double price = 100;        public void drive() &#123;            System.out.println(&quot;car ing&quot;);        &#125;        private void m() &#123;            System.out.println(&quot;outer class private method&quot;);        &#125;        public class Engine &#123;            private double price = 90;            public void turnOn() &#123;                System.out.println(&quot;engine is turning on&quot;);            &#125;            public void m2() &#123;                // inner class can use outer class private members.                System.out.println(new InnerClass().new Car().price);                drive();                m();            &#125;        &#125;    &#125;        // more public inner class(uninclude local inner class)    public class A &#123;            &#125;&#125;class InnerClassT &#123;    public static void main(String[] args) &#123;        InnerClass.Car car = new InnerClass().new Car();        InnerClass.Car.Engine engine = new InnerClass().new Car().new Engine();        engine.m2();        InnerClass.Car.Engine engine1 = car.new Engine();        InnerClassT.B.m3();        // anonymous inner class        new InterT() &#123;            @Override            public void m1() &#123;                System.out.println(&quot;anonymous inner class: interface&quot;);            &#125;            @Override            public void m2() &#123;            &#125;        &#125;.m1();        // anonymous inner class        new InterTA() &#123;            @Override            public void m1() &#123;                System.out.println(&quot;anonymous inner class:abstract&quot;);            &#125;            @Override            public void m2() &#123;            &#125;        &#125;.m1();    &#125;    // static inner class    public static class B &#123;        static void m3() &#123;            // local inner class            class C &#123;            &#125;            C c = new C();        &#125;    &#125;&#125;\n\n\n\n匿名内部类\n概述\n\n\n是内部类的简化写法。它的本质是一个带具体实现的 父类或者父接口的 匿名的 子类对象。\n\n\n格式\n\nabstract class Animal &#123;    public abstract void eat();&#125;interface IA &#123;    void show();&#125;public class Test &#123;    public static void main(String[] args) &#123;        (new Animal() &#123;            @Override            public void eat() &#123;                System.out.println(&quot;匿名内部类&quot;);            &#125;        &#125;).eat();        (new IA() &#123;            @Override            public void show() &#123;                System.out.println(&quot;匿名内部类&quot;);            &#125;        &#125;).show();        m(new Animal() &#123;            @Override            public void eat() &#123;            &#125;        &#125;);    &#125;    private static void m(Animal anl) &#123;            &#125;&#125;\n\n引用类型使用小结\n类名作为方法参数和返回值:可以直接传入该类的对象;返回该类的对象抽象类作为方法参数和返回值:只能传入该类的子类对象;返回该类的子类对象接口作为方法参数和返回值:只能传入该接口的实现类对象;返回该接口的实现类对象传递的都是地址值,返回的也是地址值\n\n\n类作为成员变量 : 赋该类的对象抽象类作为成员变量 ; 赋该类的子类对象接口作为成员变量: 赋该接口的实现类对象\n\nday04_String和StringBuilder以及集合入门String类\n概述\n\n\npublic final class String     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence\nString 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象\n\n\n常用的构造方法\n\n\n\n\n方法名\n说明\n\n\n\npublic String()\n创建一个空白字符串对象，不含有任何内容\n\n\npublic String(char[] chs)\n根据字符数组的内容，来创建字符串对象\n\n\npublic   String(char[] value, int offset, int count)\n根据指定字符数组范围的内容，来创建字符串对象\n\n\npublic String(byte[] bys)\n根据字节数组的内容，来创建字符串对象\n\n\npublic   String(byte[] bytes, int offset, int length)\n根据指定字节数组范围的内容，来创建字符串对象\n\n\nString s = “abc”;\n直接赋值的方式创建字符串对象，内容就是abc\n\n\n\n创建字符串对象两种方式的区别\n\n通过构造方法创建\n\n通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然字符串内容相同，但是地址值不同\n\n直接赋值方式创建\n\n以””方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护(是常量,在常量池中,只有一份)\n\n// 通过构造方法创建char[] chs = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;String s1 = new String(chs);// s1字符串的内容: abcString s2 = new String(chs);// s2字符串的内容: abcSystem.out.println(s1 == s2);// 比较s1和s2的地址值 false// 直接赋值方式创建String str1 = &quot;abc&quot;;// str1字符串的内容: abcString str2 = &quot;abc&quot;;// str2字符串的内容: abcSystem.out.println(str1 == str2);// 比较str1和str2的地址值 true\n\n\nString类的特点\nString类的字符串不可变，它们的值在创建后不能被更改\n\nString s1 = &quot;abc&quot;;s1 += &quot;d&quot;;System.out.println(s1); // &quot;abcd&quot; // 内存中有&quot;abc&quot;，&quot;abcd&quot;,&quot;d&quot;,3个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。\n\n\n虽然 String 的值是不可变的，但是它们可以被共享\n\nString s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。\n\n\n字符串效果上相当于字符数组( char[] )\n\n例如： String str = &quot;abc&quot;;相当于： char[] data = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;     String str = new String(data);// String底层是靠字符数组实现的,jdk9底层是字节数组。byte[] bys = &#123;97,98,99&#125;;String str = new String(bys);\n\n字符串的比较\n==号的比较\n\n\n基本数据类型：比较的是具体的值\n引用数据类型：比较的是对象地址值\n\n\nequals方法\n\npublic boolean equals(Object s)     //比较两个字符串内容是否相同、区分大小写public boolean equalsIgnoreCase (String anotherString) //将此字符串与指定对象进行比较，忽略大小写。\n\nString类获取功能的方法public int length () ：返回此字符串的长度。public String concat (String str) ：将指定的字符串连接到该字符串的末尾。拼接public char charAt (int index) ：返回指定索引处的char值。public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。public int indexOf(String str, int fromIndex)  返回从指定索引位置查找,该子字符串第一次出现在该字符串内的索引。public int lastIndexOf(String str) 返回指定子字符串最后一次出现在该字符串内的索引。public int lastIndexOf(String str, int fromIndex) 返回从指定索引位置反向(backward)查找,该子字符串最后一次出现在该字符串内的索引。public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。\n\n\n\nString类判断功能的方法boolean isEmpty(); //判断字符串是否为空(长度为0返回true，不为0返回false)boolean contains(CharSequence s);    //判断字符串中是否包含 给定的字符串。boolean endsWith(String s); //判断字符串是否以 给定的字符串 结尾。可用于判断文件类型boolean startsWith(String s); //判断字符串是否以给定的字符串 开头。\t注意:null不能调用方法,如果调用了就会报空指针异常NullPointerException\n\n\n\nString类转换功能和其他功能的方法**注意返回一个新的字符串**\nString replace(char oldChar,char newChar); //用新内容替代旧内容，返回新的字符串，String replace(CharSequence oldStr,CharSequence newStr); //用新内容替代旧内容，返回新的字符串，CharSequence是String的父接口String toLowerCase();  //把字母都转成其对应的小写形式。String toUpperCase();  //把字母都转成其对应的大写形式。char[] toCharArray() // 把字符串转换为数组byte[] getBytes() // 把字符串转换为字节数组String trim();            //移除首尾空格。String[] split(String regex);   //根据给定的内容，切割字符串，返回字符串数组\t参数regex: 分割的规则(普通的字符串,也可以是特殊的字符串(正则表达式))\n\n\n\n理解的口诀:\n\n判断功能  首尾中空加判断获取功能  截长取位取元素转换功能  大小拼串转数组 //toCharArray(), getBytes();其他功能  除空切换字典拍 //copareTo();\n\nStringBuilder类\n概述\n\n\npublic final class StringBuilder     extends AbstractStringBuilder     implements java.io.Serializable, CharSequence\nStringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的\n\n\nStringBuilder类和String类的区别\n\n\nString类：内容是不可变的,拼接耗时，又浪费空间StringBuilder类：内容是可变的\n\n\n常用的构造方法\n\n\n\n\n方法名\n说明\n\n\n\npublic StringBuilder()\n创建一个空白可变字符串对象，不含有任何内容\n\n\npublic StringBuilder(String str)\n根据字符串的内容，来创建可变字符串对象\n\n\nStringBuilder类常用方法StringBuilder与String很相似，所以有很多类似方法；但StringBuilder操作对象后会返回本身(return this)，而String是返回新对象，这也是StringBuilder的优点\npublic StringBuilder append(任意类型) 拼接数据，并返回对象本身public StringBuilder insert(int offset, 任意类型) 在指定位置插入数据,并返回对象本身public StringBuilder reverse()  反转字符串,并返回对象本身\n\nStringBuilder  ⇋  Stringpublic StringBuilder(String str);  String---&gt;StringBuilderpublic String toString();    StringBuilder---&gt;String    // new String(StringBuilder sb)\n\n\n\n集合\n概述\n\n\n集合其实就是一个大小可变的容器,可以用来存储多个引用数据类型的数据\n\n\n集合与数组的区别\n\n\n数组：数组大小固定集合：集合大小可动态扩展\n\nArrayList类\n概述\n\n\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\nArrayList类底层是一个大小可变的数组实现\n\n\n构造方法\n\n\npublic ArrayList() 构造一个初始容量为 10 的空列表。\n\nArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;();// 如果未指定&lt;E&gt;泛型，则会创建泛型为Object的ArrayList集合对象。ArrayList list1 = new ArrayList();\n\n\n\nArrayList类的方法public boolean add(E e)：将指定的元素追加到此集合的末尾public void add(int index,E element)：在此集合中的指定位置插入指定的元素public boolean remove(Object o) 删除指定的元素，返回删除是否成功public E remove(int index) 删除指定索引处的元素，返回被删除的元素public E set(int index, E element) 修改指定索引处的元素，返回被修改的元素。public E get(int index) 返回指定索引处的元素。public int size() 返回集合中的元素的个数// IndexOutOfBoundsException索引越界异常,需要注意index &lt; size\n\nInteger a = 2; // 自动装箱 基本数据类型 --&gt;包装类int c = a; // 自动拆箱 包装类 --&gt;基本数据类型\n\nday05_权限修饰符、代码块、常用API权限修饰符\n\n\n\npublic\nprotected\n（空的）\nprivate\n\n\n\n同一类中\n√\n√\n√\n√\n\n\n同一包中(子类与无关类)\n√\n√\n√\n\n\n\n不同包的子类\n√\n√\n\n\n\n\n不同包中的无关类\n√\n\n\n\n\n\n编写代码时，如果没有特殊的考虑，建议这样使用权限：\n\n成员变量使用private ，隐藏细节。\n构造方法使用public ，方便创建对象。\n成员方法使用public ，方便调用方法。\n\n代码块\n构造代码块 静态代码块 局部代码块\n\npublic class Test &#123;    public Test() &#123;        System.out.println(&quot;构造方法&quot;);    &#125;    &#123;        /*        格式: &#123;&#125;        位置: 类中,方法外        执行: 每次在调用构造方法的时候,就会执行        使用场景: 统计创建了多少个该类对象         */        System.out.println(&quot;构造代码块&quot;);    &#125;    /*        格式:static&#123;&#125;        位置: 类中,方法外        执行: 当类被加载的时候执行,并只执行一次        使用场景: 例如加载驱动,这种只需要执行一次的代码就可以放在静态代码块中        执行优先级:  静态代码块 &gt;  构造代码块  &gt;  构造方法     */    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test1 = new Test();        /*            格式:&#123;&#125;            位置: 方法中            执行: 调用方法,执行到局部代码块的时候就执行            使用场景: 节省内存空间,没有多大的意义         */        &#123;            int num1 = 10;            System.out.println(&quot;局部代码块&quot;);        &#125;        // System.out.println(num1);    &#125;&#125;// 输出静态代码块构造代码块构造方法构造代码块构造方法局部代码块// 代码块特点遵循正常逻辑，如static\n\nObject类\n概述\n\n\npublic class Object\nObject类当中包含的方法有11个,今天学习其中的2个\n\npublic String toString()：返回该对象的字符串表示。public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。    Object类的equals方法默认比较的是2个对象的地址值是否相同  == 一样的效果\n\nObjects类\n概述\n\n\n在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashCode、返回对象的字符串表示形式、比较两个对象。\n\n\n在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。\n\npublic static boolean equals(Object a, Object b) &#123;      return (a == b) || (a != null &amp;&amp; a.equals(b));  &#125;\n\nnative方法\n概述\n\n\n在Object类的源码中定义了 native 修饰的方法， native 修饰的方法称为本地方法。这种方法是没有方法体的,我们查看不了它的实现,当我们需要访问C或C++的代码时，或者访问操作系统的底层类库时，可以使用本地方法实现。\n也就意味着Java可以和其它的编程语言进行交互。\n本地方法的作用： 就是当Java调用非Java代码的接口。方法的实现由非Java语言实现，比如C或C++。\n\nDate类\n概述\n\n\npublic class Date     implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;\njava.util.Date类表示一个计算机本地系统的瞬时日期和时间，内部精确到毫秒。\n\n\n构造方法\n\npublic Date() : 创建当前系统时间对应的日期对象public Date(long date): 创建以标准基准时间为基准 指定偏移毫秒数 对应时间的日期对象\t标准基准时间:\t\t\t0时区: 1970年1月1日00:00:00 GMT             东8区: 1970年1月1日08:00:00 CST\n\n\n常用方法\n\npublic long getTime() 获取当前日期对象距离标准基准时间的毫秒值。public void setTime(long time) 设置当前日期对象距离标准基准时间的毫秒值.也就意味着改变了当前日期对象public boolean after(Date when) 测试此日期是否在指定日期之后。public boolean before(Date when) 测试此日期是否在指定日期之前。\n\nDateFormat类(SimpleDateFormat)\n概述\n\n\npublic abstract class DateFormat extends Format\njava.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,Date对象 ⇋ String对象\n\n\n特点:由于DateFormat是抽象类无法创建对象,所以只能使用其子类SimpleDateFormat\n\n\nSimpleDateFormat构造方法\n\npublic SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。// 注意 SimpleDateFormat 不是线程安全，一个线程使用它没有并发问题\n\n\nDateFormat类的常用方法\n\npublic String format(Date date)：将Date对象格式化为字符串。public Date parse(String source)：将字符串解析为Date对象。    // 需要处理解析异常/*\t常见的pattern用法\t    常见的日期格式:  yyyy年MM月dd日 HH时mm分ss秒    常见的日期格式:  yyyy-MM-dd HH:mm:ss    常见的日期格式:  yyyy-MM-dd    常见的日期格式:  HH:mm:ss\n\nCalendar类\n概述\n\n\npublic abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt;\njava.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。\n\n\n获取GregorianCalendar对象\n\n直接创建GregorianCalendar对象；通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象\n\n\nCalendar类的常用方法\n\npublic static Calendar getInstance();获取当前时间的日历对象public int get(int field) 获取某个字段的值。     参数field:表示获取哪个字段的值,可以使用Calender中定义的常量来表示         \tCalendar.YEAR : 年            Calendar.MONTH ：月            Calendar.DAY_OF_MONTH：月中的日期            Calendar.HOUR：小时            Calendar.MINUTE：分钟            Calendar.SECOND：秒            Calendar.DAY_OF_WEEK：星期public void set(int field,int value)设置某个字段的值public void add(int field,int amount)为某个字段增加/减少指定的值额外增加:public void setTime(Date date)  使用给定的 Date 设置此 Calendar 的时间。boolean before(Object when) 判断当前日历对象的时间是否在指定日历对象时间之前boolean after(Object when) 判断当前日历对象的时间是否在指定日历对象时间之后\n\nMath类\n概述\n\n\npublic final class Math\nMath类包含执行基本数字运算的方法。它不能创建对象，它的构造方法被“私有”（private修饰）了。因为内部都是“静态方法”，通过“类名”直接调用即可。\n\n\nMath类的常用方法\n\npublic static int abs(int a) 获取参数a的绝对值：public static double ceil(double a) 向上取整  例如:3.14 向上取整4.0；-3.14向上取整-3public static double floor(double a) 向下取整 例如:3.14 向下取整3.0public static double pow(double a, double b)  获取a的b次幂public static long round(double a) 四舍五入取整 例如:3.14 取整3  3.56 取整4;-3.14取整-3public static int max(int a, int b)  返回两个 int 值中较大的一个。public static int min(int a, int b)  返回两个 int 值中较小的一个。\n\nSystem类\n概述\n\n\npublic final class System\njava.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。\n\n\nSystem类的常用方法\n\npublic static void exit(int status) 终止当前运行的Java虚拟机，非零表示异常终止public static long currentTimeMillis() 返回当前时间(以毫秒为单位)static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 拷贝数组中的元素到另一个数组,目标数组会被覆盖    // 注意数组索引越界\n\nBigInteger类\n概述\n\n\npublic class BigInteger extends Number implements Comparable&lt;BigInteger&gt;\njava.math.BigInteger 类，不可变的任意精度的整数。如果运算中，数据的范围超过了long类型后，可以使用BigInteger类实现，该类的计算整数是不限制长度的。\n\n\n构造方法\n\npublic BigInteger(String val) 将十进制字符串形式转换为 BigInteger。超过long类型的范围，已经不能称为数字了，因此构造方法中采用字符串的形式来表示超大整数，将超大整数封装成BigInteger对象。\n\n\n成员方法\n\npublic add(BigInteger value)\t返回其值为 (this + val) 的 BigInteger，超大整数加法运算public subtract(BigInteger value)\t返回其值为 (this - val) 的 BigInteger，超大整数减法运算public multiply(BigInteger value)\t返回其值为 (this * val) 的 BigInteger，超大整数乘法运算public divide(BigInteger value)\t返回其值为 (this / val) 的 BigInteger，超大整数除法运算，**除不尽取整数部分**\n\nBigDecimal\n概述\n\n\npublic class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; \njava.math.BigDecimal(类):提供了更加精准的数据计算方式。\n\n\n构造方法\n\nBigDecimal(double val)\t将double类型的数据封装为BigDecimal对象BigDecimal(String val)\t将 BigDecimal 的字符串表示形式转换为 BigDecimal    推荐使用第二种方式，第一种存在精度问题；\n\n\n常用方法\n\npublic BigDecimal add(BigDecimal value)\t加法运算public BigDecimal subtract(BigDecimal value)\t减法运算public BigDecimal multiply(BigDecimal value)\t乘法运算public BigDecimal divide(BigDecimal value)\t除法运算注意：对于divide方法来说，如果除不尽的话，就会出现java.lang.ArithmeticException异常。此时可以使用divide方法的另一个重载方法；BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode):\t\tdivisor：除数对应的BigDecimal对象；         scale:精确的位数；         roundingMode取舍模式  RoundingMode枚举:RoundingMode.HALF_UP 四舍五入\n\nArrays类\n概述\n\n\npublic class Arrays\njava.util.Arrays类：该类包含用于操作数组的各种方法（如排序和搜索）\n\n*Note:\nint[] a = &#123;1, 2, 3&#125;;System.out.println(a); // [I@75b84c92System.out.println(Arrays.toString(a)); // [1, 2, 3]char[] chs = &#123;&#x27;1&#x27;, &#x27;2&#x27;, &#x27;a&#x27;&#125;;System.out.println(chs); // 12a// 这里是因为其他数组向上转型为Object对象，调用obj.toString输出地址；而char[]有单独实现输出行为,即使数组属于引用类型。可查看println源码。\n\n\n\n\nArrays类常用方法\n\npublic static void sort(int[] a)：按照数字顺序排列指定的数组public static String toString(int[] a)：返回指定数组的内容的字符串表示形式\n\n包装类之Integer类\n概述\n\n\n此处以Integer介绍,其他包装类类似\n\n\nInteger类构造方法及静态方法\n\n// 创建或获取Integer对象实例：构造方法，静态方法public Integer(int value)\t根据 int 值创建 Integer 对象(过时)public Integer(String s)\t根据 String 值创建 Integer 对象(过时)public static Integer valueOf(int i)\t返回表示指定的 int 值的 Integer 实例public static Integer valueOf(String s)\t返回保存指定String值的 Integer 实例public static int parseInt(String s) throws NumberFormatException 返回int基本数据类型,除了Character其他基本数据类型包装类都具有此方法parseXxx(String s)\n\n\n装箱拆箱\n\nInteger a = 2; // 自动装箱 基本数据类型 --&gt;包装类int c = a; // 自动拆箱 包装类 --&gt;基本数据类型\n\n基本类型 ⇋ String\n基本类型 =&gt; String\n\n\n1、基本类型+ “”\n2、String.valueOf(num)\n\n\nString =&gt; 基本类型 \n\n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型\n\npublic static int parseInt(String s)：将字符串参数转换为对应的int基本类型。\n\nday06_综合练习\n 查看pdf\n\nday07_Collection、List、泛型、数据结构Collection集合接口\n概述\n\n\npublic interface Collection&lt;E&gt; extends Iterable&lt;E&gt; \n是单列集合类的根接口，用于存储一系列符合某种规则的元素\n\n\n单列集合常用类的继承体系\n\nCollection集合:接口,是所有单列集合的顶层父接口,该集合中的方法可以被所有单列集合共享\tList集合: 接口,元素可重复,元素有索引,元素存取有序\t\tArrayList集合: 实现类,查询快,增删慢\t\tLinkedList集合: 实现类,查询慢,增删快\tSet集合: 接口, 元素不可重复(唯一),元素无索引\t\tHashSet集合: 实现类,元素存取无序\t\tLinkedHashSet集合:实现类,元素存取有序\t\tTreeSet集合:实现类,可以对集合中的元素进行排序\n\n\n\n\nCollection集合常用方法\n\n\nCollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合\n\npublic boolean add(E e)： 把给定的对象添加到当前集合中 。public void clear() :清空集合中所有的元素。public boolean remove(E e): 把给定的对象在当前集合中删除。public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。public boolean isEmpty(): 判断当前集合是否为空。public int size(): 返回集合中元素的个数。public Object[] toArray(): 把集合中的元素，存储到数组中// Collection集合提供了一个获取迭代器的方法public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。\n\nIterator迭代器\n概述\n\n\npublic interface Iterator&lt;E&gt;\n即Collection集合元素的通用获取方式。\n\n\nIterator接口的常用方法\n\npublic E next():返回迭代的下一个元素。public boolean hasNext():如果仍有元素可以迭代，则返回 true。default void remove(): 迭代时进行删除*\n\n\n迭代器常见的2个问题\n\n\n问题一:在进行集合元素获取时，如果集合中已经没有元素可以迭代了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。\n解决办法: 如果还需要重新迭代,那么就重新获取一个新的迭代器对象进行操作\n\n\n问题二:在进行集合元素迭代时，如果添加或移除集合中的元素 ,将无法继续迭代 , 将会抛出ConcurrentModificationException并发修改异常.\n解决办法：使用Iterator提供的remove方法，参考编写如下\nwhile (it3.hasNext()) &#123;        String s = it3.next();        System.out.println(s);        // col2.add(&quot;d&quot;); // 异常        // col2.remove(s); // 异常        // 迭代时删除操作        if (&quot;a&quot;.equals(s)) &#123;            it3.remove();            break;        &#125;&#125;\n\n 理解: 迭代完成,无指向数据,所以不可以继续取数据;迭代时使用集合增删数据,会破坏迭代器的指向,所以不可以使用集合增删数据.\n\n增强for\n概述\n\n\n增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。\n\n\n格式\n\nfor(元素的数据类型  变量 : Collection集合or数组)&#123;   \t...&#125;\n\n泛型\n概述\n\n\n泛型的作用是在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。\n\n\n定义和使用含有泛型的类\n\n// 定义public class Test&lt;E&gt; &#123;    private E e;    public E getE() &#123;        return e;    &#125;    public void setE(E e) &#123;        this.e = e;    &#125;&#125;// 使用Test&lt;String&gt; test = new Test&lt;&gt;();test.setE(&quot;a&quot;);System.out.println(test.getE());\n\n\n定义和使用含有泛型的方法\n\n// 定义修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;public &lt;T&gt; T m(T t)&#123;    return t;&#125;public &lt;T&gt; void m2(T t) &#123;    System.out.println(t);&#125;// 使用m(&quot;b&quot;);\n\n\n定义和使用含有泛型的接口\n\n// 定义修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;interface IA&lt;E&gt; &#123;    void m(E e);    default E m2(E e) &#123;        return e;    &#125;&#125;// 使用class Imp implements IA&lt;String&gt; &#123;    @Override    public void m(String string) &#123;    &#125;&#125;class Imp2&lt;E&gt; implements IA&lt;E&gt; &#123;    @Override    public void m(E e) &#123;    &#125;&#125;\n\n\n泛型类、方法、接口何时确定类型\n\n使用含有泛型的类:  创建该类对象的时候,指定泛型的具体数据类型使用含有方向的方法: 调用该方法的时候,确定泛型的具体数据类型使用含有泛型的接口:\t1.创建实现类实现接口的时候,指定泛型的具体数据类型    2.创建实现类实现接口的时候,不知道泛型的具体数据类型,而是创建实现类对象的时候指定泛型的具体数据类型\n\n泛型通配符\n概述\n\n\n不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。注意: 不能往该集合中存储数据,只能获取数据;泛型没有多态\n\n\n受限泛型\n\n\n上限: &lt;? extends 类名&gt;  只能接收该类类型或者其子类类型下限: &lt;? super 类名&gt;   只能接收该类类型或者其父类类型\n\n数据结构\n栈\n\n\n栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。\n特点:先进后出;栈的入口、出口的都是栈的顶端位置。\n\n\n队列\n\n\n队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行取出并删除。\n特点:先进先出;队列的入口、出口各占一侧。\n\n\n数组\n\n\n数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。\n特点:查找元素快：通过索引，可以快速访问指定位置的元素;增删元素慢(数组长度固定,需要创建新数组进行增删操作)\n\n\n\n链表\n\n\n链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n特点:多个结点之间，通过地址进行连接;查找元素慢:想查找某个元素，需要通过连接的节点，依次向后查找指定元素;增删元素快：只需要修改链接下一个元素的地址值即可\n\n\n\n树\n\n\nlue\n\nList集合接口\n概述\n\n\npublic interface List&lt;E&gt; extends Collection&lt;E&gt;\nList作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法\n\n\nList接口新增常用方法\n\npublic void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。public E get(int index):返回集合中指定位置的元素。public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。\n\nList的子类\nArrayList\n\n\njava.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快\n\n\nLinkedList\n\n\njava.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。\n\nLinkedList常用方法\nLinkedList是一个双向链表,实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法public void addFirst(E e):将指定元素插入此列表的开头。public void addLast(E e):将指定元素添加到此列表的结尾。public E getFirst():返回此列表的第一个元素。public E getLast():返回此列表的最后一个元素。public E removeFirst():移除并返回此列表的第一个元素。public E removeLast():移除并返回此列表的最后一个元素。public E pop():从此列表所表示的堆栈处弹出一个元素。public void push(E e):将元素推入此列表所表示的堆栈。\n\nday08_Collections、Set、Map、排序Collections类\n概述\n\n\npublic class Collections\njava.utils.Collections是集合工具类，用来对集合进行操作\n\n\nCollections常用方法\n\npublic static void shuffle(List&lt;?&gt; list):打乱集合顺序。public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。public static void reverse(List&lt;?&gt; list)\n\n\n排序\n\n按照默认规则排序:集合元素所属的类通过实现Comparable接口,重写compareTo(T o)方法写好排序规则\npublic class Student implements Comparable&lt;Student&gt;&#123;    private int age;    public Student(int age) &#123;        this.age = age;    &#125;        @Override    public int compareTo(Student o) &#123;        // 指定排序规则        // 前减后  升序        // 后减前  降序        // 前:this  后: 参数o        return this.age - o.age;// 升序    &#125;&#125;\n\n指定规则排序:通过传入Comparator接口的匿名内部类,重写compare(T o1,T o2)方法指定排序规则\nCollections.sort(list1, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student o1, Student o2) &#123;                return o2.getAge() - o1.getAge();            &#125;&#125;);\n\nNote:\n\n匿名对象:无指定名称的对象:new Test()\n匿名内部类:带具体实现的 父类或者父接口的 匿名的 子类对象:new IA(…)\n\n可变参数\n格式\n\n修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;public static void m(int... nums)&#123;&#125;\n\n\n注意事项\n\n\n一个方法只能有一个可变参数\n如果方法中有多个参数，可变参数要放到最后。\n\nSet集合接口\n概述\n\n\npublic interface Set&lt;E&gt; extends Collection&lt;E&gt;\n接口, 元素不可重复(唯一),元素无索引\n\n\n注意\n\n\nSet集合没有特殊的方法,都是使用Collection接口的方法Set集合没有索引,所以遍历元素的方式就只有: 增强for循环,或者迭代器\n\nSet的子类\nHashSet\n\n哈希表结构:\tjdk8以前: 数组+链表\tjdk8以后: 数组+链表+红黑树\t\t链表元素个数没有超过8: 数组+链表\t\t链表元素个数超过8: 数组+链表+红黑树HashSet集合保证元素唯一的原理--依赖存放自定义类型元素的hashCode()和equals()方法\t1.当存储元素的时候,就会调用该元素的hashCode()方法计算该元素的哈希值\t2.判断该哈希值对应的位置上,是否有元素:\t3.如果该哈希值对应的位置上,没有元素,就直接存储\t4.如果该哈希值对应的位置上,有元素,说明产生了哈希冲突\t5.产生了哈希冲突,就得调用该元素的equals方法,与该位置上的所有元素进行一一比较:\t\t如果比较的时候,有任意一个元素与该元素相同,那么就不存储\t\t如果比较完了,没有一个元素与该元素相同,那么就直接存储Object类: hashCode()和equals()方法;\thashCode():Object类中的hashCode()方法是根据地址值计算哈希值\tequals方法():Object类中的equals()方法是比较地址值\n\n\n\nLinkedHashSet\n\n\n采用哈希表+链表结构，由哈希表保证元素唯一，由链表保证元素存取有序\n\n\nTreeSet\n\n\nTreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于红黑树的实现\n\n\n特点:元素唯一        元素没有索引        使用元素的自然顺序对元素进行排序，或者根据创建 TreeSet 时提供的         Comparator 比较器进行排序\npublic TreeSet()：\t\t\t\t\t\t  根据其元素的自然排序进行排序public TreeSet(Comparator&lt;E&gt; comparator):    根据指定的比较器进行排序\n\nMap集合接口\n概述\n\n\npublic interface Map&lt;K,V&gt; \n\n\n特点\n\n\nMap集合存储元素是以键值对的形式存储,每一个键值对都有键和值Map集合的键是唯一,值可以重复,如果键重复了,那么值就会被覆盖根据键取值\n\n\nMap集合常用类的继承体系\n\nHashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。\t由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。\t通过链表结构可以保证键值对的存取顺序一致；\t通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。TreeMap&lt;K,V&gt;：TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；\t可以对元素的键进行排序，排序方式有两种:自然排序和比较器排序\n\n\nMap集合常用方法\n\npublic V put(K key, V value): 把指定的键与指定的值添加到Map集合中。public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。public V get(Object key) 根据指定的键，在Map集合中获取对应的值。public int size():集合中键值对的数量public boolean containsKey(Object key):判断该集合中是否有此键;public boolean containsValue(Object value):判断该集合中是否有此值public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中;public Collection&lt;V&gt; values(): 获取Map集合中所有的值，存储到Collection集合中(值有重复)public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。    // 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；// 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。\n\n\nMap集合遍历\n\n键找值方式\n\n1.获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset()2.遍历键的Set集合，得到每一个键。3.根据键，获取键所对应的值。方法提示:get(K key)\n\n键值对方式\n\n1.获取集合中所有键值对对象，以Set集合形式返回。  Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()2.遍历所有键值对对象的集合，得到每一个键值对(Entry)对象。3.在循环中,可以使用键值对对对象获取键和值   getKey()和getValue()\n\nMap的子类参考Set的子类\n\nHashMap\n\n\n根据键来进行存储,键产生哈希冲突会覆盖值\n\n\nLinkedHashMap\n\nTreeMap\n\n\nday09_排序算法,异常,多线程基础异常\n概述\n\n\n指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n\n异常的根类Throwable的子类\n\n\nError:严重错误Error，无法通过处理的错误，只能事先避免\nException:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的\n\n\n异常分类\n\n\n编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)java.lang.Exception运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)java.lang.RuntimeException,如NullPointerException、ArrayIndexOutOfBoundsException、ArithmeticException、ClassCastException\n\n异常的产生和处理\n异常的产生\n\n\n在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\nthrow new 异常类名(参数);// Note:异常抛出后需要处理,声明或者捕获(运行时异常被抛出可以不处理,即不捕获也不声明抛出)\n\n\n声明处理异常\n\n\n使用throws关键字将问题标识出来, 表示当前方法不处理异常，而是提醒给调用者, 让调用者来处理….最终会到虚拟机,虚拟机直接结束程序,打印异常信息。\n\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;  // 可以抛出一个,也可以多个&#125;\n\n\n特点: 声明处理异常,处理完后,如果程序运行的时候出现异常,程序还是无法继续往下执行使用场景:  声明处理异常一般处理运行的时候不会出现异常的编译异常\n\n\n捕获处理异常\n\n\n对异常进行捕获处理 , 处理完后程序可以正常向下执行。\n\npublic static void m5() &#123;        try &#123;            int i = 1 / 0;            System.out.println(&quot;异常出现停止此行及后续try语句执行&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();            System.out.println(&quot;捕获异常执行后才会catch语句，如果遇到return，记住返回值，&quot; +                    &quot;执行finally语句，如果finally有return返回其中值并终止后续语句&quot;);        &#125; finally &#123;            System.out.println(&quot;finally语句，无return继续执行后续语句&quot;);        &#125;        System.out.println(&quot;finally后的语句&quot;);&#125;\n\n\n\n\n特点:try和catch都不能单独使用,必须连用。try中的代码出现了异常,那么出现异常位置后面的代码就不会再执行了捕获处理异常,如果程序出现了异常,程序会继续往下执行\n\ntry&#123;    可能会出现异常的代码       &#125;catch(异常的类型 变量名)&#123;    处理异常的代码或者打印异常的信息&#125;finally&#123;    无论异常是否发生,都会执行这里的代码(正常情况,都会执行finally中的代码,一般用来释放资源)&#125;// 执行步骤:\t1.首先执行try中的代码,如果try中的代码出现了异常,那么就直接执行catch()里面的代码,执行完后会执行finally中的代码,然后程序继续往下执行\t2.如果try中的代码没有出现异常,那么就不会执行catch()里面的代码,但是还是会执行finally中的代码,然后程序继续往下执行\n\n\n获取异常信息\n\n\nThrowable类中定义了一些查看方法\n\npublic String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。public String toString():获取异常的类型和异常描述信息(不用)。public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。\n\n异常注意事项class Fu &#123;    public void show2() throws ParseException, IndexOutOfBoundsException &#123;&#125;    public void show3() &#123;&#125;&#125;class Zi extends Fu &#123;    // 2.如果父类的方法抛出了多个异常,子类覆盖(重写)父类方法时,只能抛出相同的异常或者是他的子集。    @Override    public void show2() throws ParseException, IndexOutOfBoundsException &#123;&#125;    // 3.父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出    @Override    public void show3() &#123;        // throw new Exception(&quot;&quot;);        try &#123;            throw new Exception(&quot;&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            异常注意事项:                1.运行时异常被抛出可以不处理。即不捕获也不声明抛出。                2.如果父类的方法抛出了多个异常,子类覆盖(重写)父类方法时,只能抛出相同的异常或者是他的子集。                3.父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出                4.声明处理多个异常,可以直接声明这多个异常的父类异常                5.在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。                6.多个异常使用捕获又该如何处理呢？                    1. 多个异常分别处理。                    2. 多个异常一次捕获，多次处理。                    3. 多个异常一次捕获一次处理。                7.当多异常分别处理时，捕获处理，前边的类不能是后边类的父类         */    &#125;    // 1.运行时异常被抛出可以不处理。即不捕获也不声明抛出。    public static void show1() &#123;        throw new ArithmeticException();    &#125;    // 4.声明处理多个异常,可以直接声明这多个异常的父类异常    public static void show4(int n) throws Exception &#123;        if (n == 1) &#123;            throw new FileNotFoundException();        &#125; else &#123;            throw new ParseException(&quot;e&quot;, 1);        &#125;    &#125;    // 6.多个异常使用捕获又该如何处理呢？    public static void show6(int n) &#123;        if (n == 1) &#123;            try &#123;                throw new FileNotFoundException();            &#125; catch (FileNotFoundException e) &#123;                e.printStackTrace();            &#125;        &#125; else &#123;            try &#123;                throw new ParseException(&quot;e&quot;, 1);            &#125; catch (ParseException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void show62(int n) &#123;        try &#123;            if (n == 1) &#123;                throw new FileNotFoundException();            &#125; else &#123;                throw new ParseException(&quot;e&quot;, 1);            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;    &#125;    // show7    public static void show63(int n) &#123;        try &#123;            if (n == 1) &#123;                throw new FileNotFoundException();            &#125; else &#123;                throw new ParseException(&quot;e&quot;, 1);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; /*catch (ParseException e) &#123;                    &#125;*/    &#125;&#125;\n\n自定义异常\n概述\n\n\n自定义一个编译期异常: 自定义类并继承于java.lang.Exception。自定义一个运行时期异常类:自定义类并继承于java.lang.RuntimeException。\n\n多线程\n并发与并行\n\n\n并行：指两个或多个事件在同一时刻发生（同时执行）。\n并发：指两个或多个事件在同一个时间段内发生(交替执行)。\n\n\n线程与进程\n\n\n进程：进程是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；\n线程：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。\n\n\n多线程并行: 多条线程在同一时刻同时执行\n多线程并发:多条线程在同一时间段交替执行\n\n\n在java中线程的调度是:抢占式调度\n在java中只有多线程并发,没有多线程并行(高并发)\n\n\n进程与线程的区别\n进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。\n\n\n线程调度\n\n分时调度\n\n所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。\n\n抢占式调度\n\n优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。\n\nThread类\n概述\n\npublic class Thread implements Runnable\n用于创建线程\n\n\nRunnable:实现此接口的子类对象可以执行线程任务\npublic interface Runnable\n\n\nThread类的构造方法\n\n\npublic Thread():分配一个新的线程对象,线程名称是默认生成的。public Thread(String name):分配一个指定名字的新的线程对象。public Thread(Runnable target):分配一个带有指定目标新的线程对象,线程名称是默认生成的。public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。// Runnable: 接口,线程任务接口创建线程的方式有2种:\t一种是通过继承Thread类的方式,重写run方法,由Thread子类对象调用run\t一种是通过实现Runnable接口的run方法,将实现类对象作为taget创建Thread对象，由Runable实现类对象调用run        // 这可使用匿名内部类的方式实现Runnable接口        注意:\t1.主线程一定会等子线程全部执行完毕才会结束主线程\t2.子线程任务代码执行完毕,线程就会销毁\n\n\nThread类的常用方法\n\npublic String getName():获取当前线程名称。public void start():导致此线程开始执行; JVM调用此线程的run方法。public void run():此线程要执行的任务在此处定义代码。    \t// Thread类的run方法代码：        @Override        public void run() &#123;            if (target != null) &#123;                target.run();            &#125;        &#125;public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。public static Thread currentThread():返回对当前正在执行的线程对象的引用。\n\nThread和Runnable的区别\n实现Runnable接口比继承Thread类所具有的优势\n\n\n可以避免java中的单继承的局限性（继承Thread不可继承其他类）。线程和任务代码是独立分块的,启动解耦操作任务资源可以被多条线程共享（多条线程可共享一个Runable实现类对象）线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。\n\nsynchronized\n概述\n\n\nsynchronized关键字：表示“同步”的。将多行代码当成是一个完整的整体，一个线程如果进入到这个代码块中，会全部执行完毕，执行结束后，其它线程才会执行。\nsynchronized被称为“重量级的锁”方式，也是“悲观锁”——效率比较低。\n\n\nsynchronized的使用方式\n\n同步代码块及其锁对象\npublic void run() &#123;        while (true) &#123;            /*            同步代码块:                概述:synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问                格式:                    synchronized(锁对象)&#123;                    &#125;                锁对象:                    1.语法上,锁对象可以是任意类的对象                    2.多条线程想要实现同步,必须锁对象一致            */            synchronized (this) &#123;                if (tickets &lt; 1) &#123;                    break;                &#125;                try &#123;                    Thread.sleep(100);                    System.out.println(Thread.currentThread().getName() + tickets + &quot;号&quot;);                    tickets--;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;\n\n同步方法及其锁对象\npublic void run() &#123;        while (true) &#123;            if (sellTickets()) &#123;                break;            &#125;        &#125;    &#125;    /*    同步方法:        概述:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。        格式:        \t修饰符 synchronized 返回值类型 方法名(形参列表)&#123;            &#125;        锁对象:            非静态同步方法: 锁对象是this            静态同步方法: 锁对象是该方法所在类的字节码对象(类名.class)    */    public synchronized boolean sellTickets() &#123;        if (tickets &lt; 1) &#123;            return true;        &#125;        try &#123;            Thread.sleep(100);            System.out.println(Thread.currentThread().getName() + tickets + &quot;号&quot;);            tickets--;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return false;    &#125;\n\n开发中,一条线程使用的是同步代码块,一条线程使用的是同步方法,但这2条线程需要实现同步---&gt;实现这个需求,同步代码块和同步方法的锁对象必须一致,而同步方法的锁对象是默认的,所以必须清楚同步方法的锁对象\nLock锁\n概述\n\n\npublic interface Lock\njava.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更加面向对象，将加锁与释放锁进行了方法化。\n一般使用实现类ReentrantLock\n\n\nLock的方法\n\npublic void lock():加同步锁。public void unlock():释放同步锁。\n\n高并发及线程安全\n高并发：是指在某个时间点上，有大量的用户(线程)同时访问同一资源\n线程安全：在某个时间点上，当大量用户(线程)访问同一资源时，由于多线程运行机制的原因，可能会导致被访问的资源出现”数据污染”的问题。\n\n多线程的运行机制\n概述\n\n当一个线程启动后，JVM会为其分配一个独立的”线程栈区”，这个线程会在这个独立的栈区中运行。\n\n\n\n\n\n问题\n\n\n多个线程在各自栈区中独立、无序的运行，当访问一些代码，或者同一个变量时，就可能会产生一些问题\n\n多线程的安全性问题","categories":["study"],"tags":["Java"]},{"title":"Ubuntu使用记录手册","url":"/2021/08/18/Ubuntu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E6%89%8B%E5%86%8C/","content":"Ubuntu的安装\n默认安装，一路到底。\n编辑虚拟机设置：选择CD、DVD &gt; iso镜像\n启动虚拟机：默认配置，选择自己喜欢的语言，配置用户密码。\n如果不能进入虚拟机系统，停止虚拟机，编辑虚拟机设置：取消选择显示器 &gt; 加速3D图形\n\nVMware Tools安装\n打开 VMware Workstation &gt; 虚拟机 &gt; 安装VMware Tools\n查看新生成的VMware Tools 的驱动器，执行如下命令输入yes并一路回车\n\nmkdir /home/lee/vmtoolscp VMwareTools-10.3.10-13959562.tar.gz -C /home/lee/vmtoolstar -zxvf VMwareTools-10.3.10-13959562.tar.gz -C /home/lee/vmtoolssudo ./vmware-install.pl\n\nUbuntu初始操作\n设置虚拟机静态IP，且重启不会重置DNS：参考此链接，或如下简述命令\n\n# 1.VMware Settings# Refer to the link,or search# 2.Ubuntu Settings# Use &#x27;vi&#x27; to editsudo vi  /etc/network/interfaces\t# update the following content# begin# According to the actual situation fill inauto loiface lo inet loopbackauto ens33iface ens33 inet staticaddress 192.168.8.100netmask 255.255.255.0gateway 192.168.8.2# end# 3.DNS Settings sudo vi /etc/resolv.conf\t# add the following content# beginnameserver 223.5.5.5# endsudo vi /etc/resolvconf/resolv.conf.d/base\t# Set up a permanent DNS,add the following content# beginnameserver 223.5.5.5nameserver 8.8.8.8# endsudo /etc/init.d/networking restart\t\t# restart net-service# Update the proxy in China # System Settings &gt; Software &amp; Updates :更改下载源为中国阿里sudo apt update &amp;&amp; sudo apt upgrade  # update software sourcesudo apt autoremove  # clean the useful package# The Locking Screen Settings# System Settings &gt; Brightness &amp; Lock :关闭定时锁屏# The cursor Settings# Open Terminal &gt; Edit &gt; Profile &gt; Cursor Shape # Create an initial snapshot with network configuration, personalized configuration","categories":["study"],"tags":["Ubuntu","note"]},{"title":"Ubuntu常用软件及配置","url":"/2021/05/12/Ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8F%8A%E9%85%8D%E7%BD%AE/","content":"基于Ubuntu16.04的个人学习积累软件记录\n前言\n很多部分都是基于其他博文写的，未完成的部分代表我未使用，只是钟意此软件，以后使用时再去解决；完成的部分都是实践过的。\n\n用处\n 主要方便更换设备快速搭建熟悉的平台供自己使用！\n\n常用网址GitHub下载提速1：源于网站GitHub下载提速2:源于b站\nNote只是针对个人的使用习惯的记录，请勿直接使用，可能导致不适配。 以下针对接触情况每个分为一个小板块介绍,引号内空白内容表示按需而定！\n#初次进入系统apt update &amp;&amp; apt upgrade -y\njdkapt-cache search java | grep jdkapt install &quot;   &quot;#系统默认配置环境变量vim etc/profile#添加环境变量#set java envexport JAVA_HOME=/usr/lib/jdk/&quot; \t&quot;export JRE_HOME=$&#123;JAVA_HOME&#125;/jre    export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib    export PATH=$&#123;JAVA_HOME&#125;/bin:$PATHjava -version\n\ntree#树形目录结构apt install tree#tree #tree -L N\n\nvimvim -version\nvundle\nvim插件第三方管理，相同的有pathogen\n\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim#配置文件cd ~/.vimrc#添加插件#添加插件配置\n\ngitapt install gitgit --version\n\nhttpie\n一款HTTP命令行的客户端，目标是让 CLI 和 web 服务之间的交互尽可能的人性化。这个工具提供了简洁的 http 命令，允许通过自然的语法发送任意 HTTP 请求数据。\n\npandoc\n 一款文本格式互相转换的软件\n\nzsh\n什么是oh my zsh启发：B站的一个up主的github\n\ntmux\n一款终端复用软件,screen与此类似好像。\n\npowervim\n一款个性化的vim配置，用于各种语言的vim开发，支持自定义。spacevim与此类似，只是对vim的原生更改的比较多。这些都是我在想实现ipad远程ssh服务器简单实现编程了解到的,现在已经实现了使用code-server云端IDE暂搁了！！！\n\ncode-server\n类似于腾讯云函数服务\n\ncd ~#下载tar.gz,我的是3.1.4 linux x86_64#Ubuntu16.04 阿里云服务器#解压tar -zxvf code-server-3.4.1-linux-x86_64.tar.gz#进入解压后的目录执行以下命令cd code-server-3.4.1-linux-x86_64# 使用 ./coder-server --help查看用户文档#设置阿里云示例安全组，放开你需要的port#配置信息：密码、访问权限、端口 运行任务并挂起export PASSWORD=&quot;你的密码&quot;   &amp;&amp;  nohup ./coder-server --bind-addr 0.0.0.0:urport &gt; urlogtxt.log  &amp;##然后就可以使用浏览器输入密码访问了ip:port#实际上就是一个vscode云端版本，配置什么的都可以参考vscode#iPad下载servediter（或者vsapp），配置信息参考此链接https://blog.csdn.net/liteng607/article/details/106601569#就可以使用了##接下来是我个人参考网上教程搞得Java开发环境##搜索插件##Chinese (Simplified) Language Pack for Visual Studio Code 中文##Java Extension Pack Java开发环境包## IntelliJ IDEA Keybindings  idea快捷方式，有点小小小的问题，可能是我的问题，不过是真的惊到我了，属实好用；eclipse的可以装对应插件##所有的东西都是在远端服务器完成，所以有时候会很慢，但是是真的好用，相对于我来说。\n\n注意：只要服务器重启，此进程就会杀掉，需要重启，如果经常重启服务器可以写个脚本启动服务。\n\n\n参考链接：这几个是安装code-servercode-server安装使用code-server+VSApp在iPad上使用VSCode在线ide code-server运行起来过程中踩到的坑及解决方法为 iPad 部署基于 VS Code 的远程开发环境\n\n\n这个是配置开发环境的vscode官方vscode安装和使用 Java这几个是使用过程的小问题VS Code 自动生成get-set方\n\n\n这是我实现浏览器或者iPad连接服务器进行编程的软件，实际效果还是可以的，完全足够胜任日常轻度的学习使用。\n\n","categories":["study"],"tags":["ubuntu-app"]},{"title":"Windows软件备忘","url":"/2021/05/12/Windows%E8%BD%AF%E4%BB%B6%E5%A4%87%E5%BF%98/","content":"google7z百度网盘icecream pdf editorpscapturetimtyporaicecream pdf逍遥模拟器\njdk8tomcatredismavenideamysqlsqlyogputtygitfiddle4vmwarenodejsvscodeframework core 5pycharmpython375navicat  premium 15\n","categories":["study"],"tags":["windows-app"]},{"title":"test categories and tags","url":"/2021/05/09/categories%20and%20tags/","content":"\n分类和标签规定分类：三大类study、work、life规定标签： 程序语言(必须) + 特别的特征(可选);或者note、test\n\n","categories":["study"],"tags":["Java","note","test","CSharp","Python"]},{"title":"使用Github-Actions搭建hexo博客及问题","url":"/2021/05/10/%E4%BD%BF%E7%94%A8Github-Actions%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%8F%8A%E9%97%AE%E9%A2%98/","content":"hexo本地安装及自动部署\nNodejs14\nHexo5.4.0\nGit2.19.0\nWindows10\n说明性内容比较多，方便理解，详细配置都指明了官方链接\n\n本地安装\n本地安装：hexo官网教程\n\n*远端部署\n远端部署：将 Hexo 部署到 GitHub Pages\n个人觉的此方法的远端部署没有改变本质，还是需要hexo生成public文件夹再推到GitHub Pages，仅仅方便后续浏览\n\n自动部署到GitHub Pages\n网上关于部署的方法也很多，但是自己部署时总是会遇到一些莫名奇妙的问题：总的来说就是Github Actions的自动化流程错误导致的，具体可以借鉴别人写的流程\n在实现自动部署之前，需要实现hexo本地安装并且可以正确访问。\n其实也可以仅仅本地保留博客文章资源，其余全部(包括主题，只需将主题配置文件备份到本地)使用Github Actions自动化生成。但是这样不利于后期个性化，容错性也比较差。\n\nhexo和主题配置\nhexo有许多主题,也可以在GitHub上直接搜索，此处配置的是keep主题官网\nhexo和keep主题的_config.yml文件跟着官方修改为适合自己的就可以了，官方文档此处也是比较详细的。\n\nGitHub配置\nkeep官方自动部署配置，较为简单快速。\n简要流程：使用远端私有仓库hexo-source存储hexo源文件，公开仓库GITHUB_USERNAME.github.io存储hexo generate的./public的站点资源文件；另外需要生成一个Token,需要赋予此令牌repo和workflow权限：此令牌配置到私有仓库hexo-source的Settings -&gt; Secrets -&gt; Actions -&gt; New(命名为HEXO_DEPLOY)用于执行workflow下，并将生成的public资源文件部署到公开仓库GITHUB_USERNAME.github.io。配置Token后需要对应更改.github\\workflows\\hexo-deploy.yml中的secrets.HEXO_DEPLOY\n此处使用的是全局Token令牌，权限比较大。这篇文章利用deploy keys 获取权限部署 hexo 博客\n\nGit配置\n在完成上述Github配置后，在本地hexo主目录下与远端私有仓库hexo-source建立连接，推送到远端即可实现自动化。\n\n本地无hexo环境实现hexo new post\nhexo new post hello_world: 创建文章前含有scaffolds\\post.md中的内容(也就是hexo官方的front-matter)，需要使用脚本写入此处内容，scaffolds\\post.md的修改也请修改为下面的post_new_dont_use_hexo.bat内容：其中可根据自己情况修改\n\n@echo off%用于本地未配置hexo环境生成文章%%输入文章名称%:whileset /p filename=请输入文章名称：if exist source\\_posts\\%filename%.md (\tgoto :while)%因为不使用hexo new post filename 生成文章，需要写入scaffolds\\posts.md内容%(echo ---echo title: %filename%echo date: %date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%echo categories:echo     - studyecho tags:echo     - echo ---) &gt; source\\_posts\\%filename%.md%Typora安装位置:home、work%set toolpath=&quot;&quot;if exist &quot;E:\\Typora\\Typora\\Typora.exe&quot; (    set toolpath=&quot;E:\\Typora\\Typora\\Typora.exe&quot;)if exist &quot;H:\\Typora\\Typora\\Typora.exe&quot; (    set toolpath=&quot;E:\\Typora\\Typora\\Typora.exe&quot;)start %toolpath% &quot;source\\_posts\\%filename%.md&quot;\n\nGit一键推送\n在与远端私有仓库hexo-source建立连接后，也是可以使用push_hexo_source.bat实现\n\n@echo offgit add .git commit -m &quot;Update&quot;git push origin master\n\n问题及解决图片的插入\n资源文件夹，我仍在使用markdown语法引用图片\n建立source/images文件夹，Typora 菜单栏 -&gt; 格式 -&gt; 当插入图片时  -&gt; 修改为 自动复制到指定路径:../images/$&#123;filename&#125;/，在文章中粘贴后图片自动复制\n在本地阅读时，只需将Typora 菜单栏 -&gt; 格式 -&gt; 设置图像根目录，将其设置为source\n\n图表的插入\n此处暂未使用过，可以使用js的插件：echarts，在文章中直接调用，实现图表显示\n\n生成的index.html内容为空\n出现这种问题，可以正常访问站点，但是却得不到内容，公开仓库xxx.github.io的index.html为空，网上说是nodejs版本过低，使用12+可以解决，我当时使用的是14也出现此问题，重复几次部署后意外正常。\n\n远程部署缺失文件\nGithub Action可以查看日志信息，如果出现文件缺失，或者上一条类似问题，可以先查看日志。\n我这里遇到了一个因为front matter错误导致编译失败，导致此文件缺失。\n\n\n发布时隔undefined\n系统时区与生成站点使用的时区不一致，导致时间差非法，可在.github\\workflows\\hexo-deploy.yml明确时区\n\n访问速度较慢\n可以使用CDN加速\n\nkeep主题配置后不生效\n因为我使用了平滑升级，推送时keep.yml覆盖了_config.yml，因此在推送前我将_config.yml复制到了keep.yml中便可以解决。\n\n","categories":["life"],"tags":["hexo","Github-Actions","hexo-keep-theme"]},{"title":"常用笔记链接","url":"/2021/05/12/%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0%E9%93%BE%E6%8E%A5/","content":"\n由于CSDN奇妙的markdown语法，迁移后格式异常，所以直接放置链接\n\n\n笔记部分\n\n\nJunit 反射 注解\nMySQL基础知识\nMySQL约束\nMySQL多表和事务\nJDBC\nJDBC连接池&amp;JDBCTemplate\nHTML&amp;CSS\nJavaScript（1）\nJavaScript（2）\nXML\nTomcat &amp; Servlet\nServlet &amp; Http &amp; Request\nResponse\nCookie &amp; Session\nEL &amp; JSTL\nFilter&amp;Listener\nJQuery 基础\nJQuery高级\nAJAX &amp; JSON\nredis\nMaven\nLinux\nMyBatis 1\nMyBatis 2\nMyBatis 3\nMyBatis 4\n\n\n\n总结部分\n\n\n关于Properties的使用\nJava通知方法\n\n","categories":["study"],"tags":["note"]},{"title":"文章资源检索收集","url":"/2021/08/18/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90%E6%A3%80%E7%B4%A2%E6%94%B6%E9%9B%86/","content":"\n将比较好的问题讲解链接搜集到此处，也收集其他资源，进行分类管理。\n\n前端css浮动vscode搭建Java Web项目\n","categories":["study"],"tags":["note"]},{"title":"跨设备同步vscode配置","url":"/2021/05/20/%E8%B7%A8%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5vscode%E9%85%8D%E7%BD%AE/","content":"\n利用插件Syncing实现跨设备同步vscode设置，包括安装的插件和配置项。也可以以实现自动同步。\n\nSyncing\nSyncing (源码) 是一个 VSCode 扩展，它能在多台设备之间同步您的所有 VSCode 配置（借助了 GitHub Gist）。\n具体详情查看官方描述。下面只记录自己的使用步骤：Windows-&gt;Windows\n\n安装Syncing扩展\n本地和需要更换到的目标设备上vscode都需要安装\n\n快速使用\n申请一个有Gist权限的GitHub Personal Access Token，记住此令牌\n在 VSCode 的命令面板中，您可以输入 upload、download（或者 syncing）来快速搜索和执行 Syncing 的所有命令。\n使用upload根据提示输入Token、默认ID即可，上传完成\n使用download根据提示输入，等待下载配置\n\n上传简要说明\n用户设置 快捷键扩展 语言设置以及所有代码片段（Snippets）\n自动创建Gist保存vscode的配置\n也可以自定义上传配置项和扩展\n跨设备需另行注意\n\n下载简要说明\n下载配置时会覆盖您的本地配置（以云端为准，精确同步）\n自动安装、升级和删除扩展\n\n","categories":["study"],"tags":["vscode"]}]