<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Blog">
    <meta name="description" content="Personal Website">
    <meta name="author" content="oo">
    
    <title>
        
            Java基础 |
        
        oo
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"eryueup.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                oo
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java基础</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">oo</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-08-26 00:21:27
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/study/">study</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>20.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>80 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Java是面向对象、跨平台的高级编程语言</p>
<p>JVM：Java虚拟机，JVM是实现Java程序跨平台的基石，本身并不支持跨平台。Java程序一次编译,到处运行</p>
</blockquote>
<h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><blockquote>
<ul>
<li><p>JVM: Java虚拟机,是专门用来运行Java程序的,但是不能单独安装</p>
</li>
<li><p>JRE: Java运行环境,包含JVM和核心类库</p>
</li>
<li><p>JDK: Java程序开发工具包,包含JRE和开发工具</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>三者关系： JDK &gt; JRE &gt; JVM</p>
</blockquote>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add system env variables</span></span><br><span class="line"><span class="comment"># JAVA_HOME: Java installation directory</span></span><br><span class="line"><span class="comment"># PATH: %JAVA_HOME%\bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># java -version</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><blockquote>
<p>Java程序开发步骤：</p>
<p><code>*.java源文件---javac编译---&gt;*.class字节码文件---java执行---&gt;JVM</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Moments of fun</span></span><br><span class="line"><span class="comment"># javac A.java</span></span><br><span class="line"><span class="comment"># java A</span></span><br></pre></td></tr></table></figure>

<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><ul>
<li>进制</li>
</ul>
<blockquote>
<p>十进制、二进制、八进制、十六进制</p>
</blockquote>
<ul>
<li>进制转换</li>
</ul>
<blockquote>
<ul>
<li><p>①十进制–&gt;二进制</p>
<p>整数：”除2取余，逆序排列”。截至余数为0，10(10)-&gt; 1010(2)</p>
<p>小数：”乘2取整，顺序排列”。截至乘积小数位为0，0.125(10) -&gt; 0.001(2) </p>
<p>负数：-42 -&gt; 正数42(10) -&gt; 00101010(2) -&gt; 取反加1-&gt;11010101(2) + 1(2) -&gt; 11010110(2)</p>
</li>
<li><p>②二进制–&gt;十进制</p>
<p>整数、小数举例：11.11(2) -&gt; 3+2^(-1)^+2^(-2)^ -&gt; 3.75(10)</p>
<p>负数：11010110(2) -42 -&gt; 减1取反 00101010(2) -&gt; -42(10)</p>
</li>
</ul>
</blockquote>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote>
<ul>
<li><p>整型常量：10</p>
</li>
<li><p>浮点型常量：0.5</p>
</li>
<li><p>字符型常量：’a’ ，&#39;<Space>&#39;，’你’。<code>&#39;&lt;Nothing&gt;&#39;,&#39;你好&#39;是不合法的</code>。此处表示空格与空的区别。</p>
</li>
<li><p>布尔型常量：true false</p>
</li>
<li><p>字符串常量：”a”，””，”  “，”ab”，”你好”</p>
</li>
<li><p>空常量：null</p>
</li>
</ul>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>变量概念: 在程序的执行过程中,其值可以在一定范围内发生改变的量。开辟的内存空间</p>
</blockquote>
<blockquote>
<ul>
<li><p>基本数据类型：包括 整型 、 浮点型 、 字符型 、 布尔型 。</p>
</li>
<li><p>引用数据类型：包括 类 、 数组 、 接口 。</p>
</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4.png"
                     
                ></p>
<blockquote>
<p>整数类型是 int 、浮点类型是 double </p>
</blockquote>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><blockquote>
<p>自定义的类、方法、属性等名称</p>
</blockquote>
<ul>
<li>命名规则</li>
</ul>
<blockquote>
<p>标识符可以包含 英文字母(区分大小写) 、 0-9 、 $ 和 _</p>
<p>标识符不能以数字开头</p>
<p>标识符不能是关键字</p>
</blockquote>
<ul>
<li>命名规范</li>
</ul>
<blockquote>
<p>类名规范：大驼峰式</p>
<p>方法名规范：小驼峰式</p>
<p>变量名规范：小驼峰式</p>
</blockquote>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul>
<li>自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。</li>
</ul>
<blockquote>
<p>byte、short、char–&gt;int–&gt;long–&gt;float–&gt;double</p>
<p>byte、short、char 运算时直接提升为 int 。</p>
</blockquote>
<ul>
<li>强制转换：将 取值范围大的类型 强制转换成 取值范围小的类型 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = b1 + b2;</span><br><span class="line"><span class="comment">// Compile Error: byte--&gt;int</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote>
<ul>
<li>算数运算符<code>+ - * / % +=...++ --</code></li>
<li>赋值运算符<code>+= -= *= /= %=</code></li>
<li>自增自减运算符<code>++ --</code></li>
<li>关系运算符<code>== != &gt;= &lt;= &gt; &lt;</code></li>
<li>逻辑运算符<code>&amp; | ! ^</code>，短路与或<code>&amp;&amp; ||</code>与<code>&amp; |</code>结果一致，但可以提高效率，&amp;&amp;左侧fasle结束，||左侧true结束</li>
<li>三元运算符<code>关系表达式 ? 表达式1 : 表达式2</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>%:奇偶、取各个位的数：num%10取个位数，num/10%10取十位数</code></li>
<li><code>+=,-=,/=,*=,%= 运算结果的数据类型和左侧变量的数据类型不一致,隐藏强制类型转换</code></li>
<li><code>整数常量只要不超出所赋值的整数变量的取值范围,可以直接赋值,内部隐藏强制类型转换</code></li>
</ul>
</blockquote>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li>顺序结构</li>
<li>选择/分支结构：if、switch</li>
<li>循环结构：for、while、do-while</li>
</ul>
<blockquote>
<p>for、while：先判断后执行；for变量一般是临时、while变量一般是外部</p>
<p>while、do-while：do-while先执行后判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">1</span>) System.out.println(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// switch</span></span><br><span class="line">        <span class="comment">// switch后面()中的表达式的数据类型,只能是以下几种类型:</span></span><br><span class="line">        <span class="comment">//      基本类型: byte/short/char/int 都可以</span></span><br><span class="line">        <span class="comment">//      引用类型: String或者枚举</span></span><br><span class="line">        <span class="comment">// case 后面只能写常量,而且常量值不能重复</span></span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>for</li>
<li>while</li>
<li>do-while</li>
</ul>
<p><code>循环跳转：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>（结束循环；结束整个<span class="keyword">switch</span>语句）</span><br><span class="line"><span class="keyword">continue</span>（结束本次循环继续下次循环：<span class="keyword">continue</span>的循环体中的语句本次不会执行）</span><br></pre></td></tr></table></figure>

<p><code>循环嵌套: </code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式<span class="number">1</span>;布尔表达式<span class="number">2</span>;步进表达式<span class="number">7</span>)&#123;<span class="comment">//外层循环</span></span><br><span class="line"> <span class="keyword">for</span>(初始化表达式<span class="number">3</span>;布尔表达式<span class="number">4</span>;步进表达式<span class="number">6</span>) &#123;<span class="comment">//内层循环</span></span><br><span class="line">      内层循环的循环体<span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">其它语句;</span><br></pre></td></tr></table></figure>

<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p><code>java.util.Random</code>：左闭右开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">随机<span class="keyword">int</span>：nextInt()</span><br><span class="line">[<span class="number">0</span>,<span class="number">99</span>]: nextInt(<span class="number">100</span>)    </span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>]: nextInt(<span class="number">5</span>) + <span class="number">1</span></span><br><span class="line">[<span class="number">66</span>,<span class="number">178</span>]: nextInt(<span class="number">113</span>) + <span class="number">66</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>特点：引用类型；可存储多个数据；可存储的数据类型需要一致；数组一旦创建长度不可变。</li>
<li>定义格式：int[] a; int a[]</li>
<li>初始化格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动态初始化（指定长度）int[] c = new int[3];</span><br><span class="line">标准格式静态初始化(指定数组元素)  int[] c = new int[]&#123;1,2,3&#125;;</span><br><span class="line">简化格式静态初始化(指定数组元素) int[] c = &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li> 数组元素有默认值:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.整数:       0</span><br><span class="line">2.小数:       0.0</span><br><span class="line">3.字符:       空白字符</span><br><span class="line">4.布尔:       false</span><br></pre></td></tr></table></figure>

<ul>
<li>两个数组指向同一内存地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = a;</span><br><span class="line"><span class="comment">// 操作任何一个改变的是同一个数组</span></span><br></pre></td></tr></table></figure>

<p>Java的内存分配：</p>
<blockquote>
<p>1.方法区: 存储可以运行的class文件。<br>2.方法栈: 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。存储局部变量。<br>3.堆内存: 存储对象或者数组，new来创建的，都存储在堆内存。<br>4.寄存器: 给CPU使用，和我们开发无关                              不关心<br>5.本地方法栈: JVM在使用操作系统功能的时候使用，和我们开发无关。        不关心</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png"
                     
                ></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>形参和实参</li>
</ul>
<blockquote>
<p>形参：方法定义的形式参数</p>
<p>实参：方法调用的实际参数（含变量）</p>
</blockquote>
<p><code>方法参数是基本类型: 形式参数的改变,不会影响实际参数(调用时以复制数据形式)</code><br><code>方法参数是引用类型: 形式参数的改变,会影响实际参数,如修改数组或者集合中的某个值(调用时以地址形式，内存地址不会改变)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        change(a);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        arr[<span class="number">0</span>] *= arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        a *= <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>方法重载</li>
</ul>
<blockquote>
<p>有关要素：方法名称相同、参数类型不同(*参数个数相同但类型位置不同)、参数个数不同有关</p>
<p>无关要素：与参数名称、返回值类型、方法修饰符无关</p>
</blockquote>
<p><code>重载形式参数为基本数据时，未重载byte会去调用int、未long会double</code></p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="day01-类和面向对象"><a href="#day01-类和面向对象" class="headerlink" title="day01_类和面向对象"></a>day01_类和面向对象</h2><h3 id="面向对象和面向过程编程思想"><a href="#面向对象和面向过程编程思想" class="headerlink" title="面向对象和面向过程编程思想"></a>面向对象和面向过程编程思想</h3><ul>
<li>面向过程编程思想</li>
</ul>
<blockquote>
<p>强调的是过程,必须清楚每一个步骤,然后按照步骤一步一步去实现</p>
</blockquote>
<ul>
<li>面向对象编程思想</li>
</ul>
<blockquote>
<p>强调的是对象, 通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>类是用来描述一类具有<code>共同属性和行为事物的统称</code>。所以其实类在客观世界里是不存在的，<code>是抽象</code>的，只是用来描述数据信息的。</p>
</blockquote>
<ul>
<li>组成</li>
</ul>
<blockquote>
<p>属性：该事物的状态信息</p>
<p>行为：该事物能做什么</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li>概念</li>
</ul>
<blockquote>
<p>对象是一个类的实例，具体存在的（如对属性进行赋值、行为进行操作），并且具备该类事物的属性和行为</p>
</blockquote>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><ul>
<li>类是对一类具有共同属性和行为的事物的统称,是抽象的</li>
<li>对象是一类事物的具体实例,可实际操作,真实存在的实体,是具体的</li>
<li>类是对象的抽象,对象是类的实体（实例）</li>
</ul>
<h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><ul>
<li>类的组成</li>
</ul>
<blockquote>
<p>属性（成员变量）、行为（成员方法）</p>
</blockquote>
<ul>
<li>类的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="comment">// 类里面:属性(成员变量),行为(成员方法)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">	<span class="comment">// 定义成员变量</span></span><br><span class="line">    数据类型 变量名<span class="number">1</span>;</span><br><span class="line">    数据类型 变量名<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 定义成员方法</span></span><br><span class="line">    方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h3><ul>
<li>对象的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的使用</li>
</ul>
<blockquote>
<p><code>.运算符</code></p>
</blockquote>
<h3 id="成员变量默认值"><a href="#成员变量默认值" class="headerlink" title="成员变量默认值"></a>成员变量默认值</h3><blockquote>
<p>整数类型: 默认值是0<br>浮点类型: 默认值是0.0<br>布尔类型: 默认值是false<br>字符类型: 默认值是不可见字符 ‘\u0000’<br>引用类型: 默认值是null</p>
</blockquote>
<h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><ul>
<li>单个对象内存图</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"
                      alt="Java单个对象的内存图"
                ></p>
<blockquote>
<p>只要创建对象,就会在堆区开辟一块空间(new会在堆区开辟一块新的空间存放成员变量(有默认值)和成员方法地址值)</p>
<p>只要调用方法,就会在栈区开辟一块空间,用来执行该方法</p>
</blockquote>
<ul>
<li>多个对象内存图</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"
                      alt="Java多个对象的内存图"
                ></p>
<blockquote>
<p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自对象的内存区域中，成员方法多个对象共用一份（方法区中，使用时加载入栈）</p>
<p>凡是new就会重新在堆区开辟一块新空间</p>
<p><code>对象和对象之间的关系是相互独立的</code></p>
</blockquote>
<ul>
<li>多个变量指向相同对象内存图【理解】</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.png"
                      alt="Java多个变量指向同一个对象"
                ></p>
<blockquote>
<p>当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）</p>
<p>只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。</p>
<p>引用类型传递的是地址值</p>
</blockquote>
<h3 id="成员变量和局部变量的区别【理解】"><a href="#成员变量和局部变量的区别【理解】" class="headerlink" title="成员变量和局部变量的区别【理解】"></a>成员变量和局部变量的区别【理解】</h3><blockquote>
<p>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</p>
<p>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</p>
<p>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，随着方法的调用完毕而消失）</p>
<p>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>private关键字</li>
</ul>
<blockquote>
<p>private修饰的成员变量或者成员方法,只能在本类中访问</p>
</blockquote>
<p><code>封装概述</code></p>
<blockquote>
<p>是面向对象三大特征之一（封装，继承，多态）<br>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</p>
</blockquote>
<p><code>为什么对属性进行封装</code></p>
<blockquote>
<p>如果通过对象名直接访问成员变量的方式来对属性赋值,会存在数据安全隐患；不让外界直接访问成员变量(也就是要对属性进行封装)，提供公共的访问方法，进行数据校验保证数据安全</p>
</blockquote>
<p><code>对成员变量封装的步骤(原则)</code></p>
<blockquote>
<p>1.使用private关键字修饰成员变量，将类的某些信息隐藏在类的内部，不允许外部程序直接访问<br>2.提供公共的访问方法:<br>给成员变量赋值的公共方法(set方法)<br>获取成员变量值的公共方法(get方法)</p>
</blockquote>
<p><code>封装优点</code></p>
<blockquote>
<p>通过类提供的公共方法来控制对成员变量的操作，提高了代码的安全性<br>把代码用方法进行封装，提高了代码的复用性</p>
</blockquote>
<ul>
<li>set和get方法</li>
</ul>
<blockquote>
<p>由于属性使用了private关键字修饰,在其他类中无法直接访问,所以得提供公共的访问方法,叫做set和get方法,用public修饰</p>
</blockquote>
<ul>
<li>this关键字</li>
</ul>
<blockquote>
<p>this关键字其主要作用是区分同名的局部变量和成员变量</p>
<p>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量<br>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97.png"
                      alt="this关键字"
                ></p>
<blockquote>
<p>this可以调用成员变量、成员方法、构造方法（解决代码冗余问题）</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>完成对象的创建和对象数据的初始化</p>
</blockquote>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空参构造方法</span></span><br><span class="line">修饰符 类名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造方法</span></span><br><span class="line">修饰符 类名(参数列表)&#123;</span><br><span class="line">	<span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果创建了有参构造方法，不会默认提供无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>特点</li>
</ul>
<blockquote>
<p>构造方法的方法名和类名一致<br>构造没有返回值<br><code>如果没有定义构造方法，系统将给出一个默认的无参数构造方法;如果定义了构造方法，系统将不再提供默认的构造方法</code><br>构造方法可以重载<br>构造方法只可以赋值一次，调用即创建新对象，可以使用set赋值</p>
</blockquote>
<h3 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>JavaBean</code> 是 Java语言编写类的一种标准规范。符合<code>JavaBean</code> 的类，要求类必须是公共的，属性使用private修饰,并且具有无参数的构造方法，提供用来操作成员变量的<code>set</code> 和<code>get</code> 方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  <span class="comment">//成员变量  private</span></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">  <span class="comment">//满参构造方法【建议】</span></span><br><span class="line">  <span class="comment">//getXxx()</span></span><br><span class="line">  <span class="comment">//setXxx()</span></span><br><span class="line">  <span class="comment">//成员方法	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h2 id="day02-静态、继承、模板设计模式、抽象类、final"><a href="#day02-静态、继承、模板设计模式、抽象类、final" class="headerlink" title="day02_静态、继承、模板设计模式、抽象类、final"></a>day02_静态、继承、模板设计模式、抽象类、final</h2><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>指没有名称的对象</p>
</blockquote>
<ul>
<li>特点</li>
</ul>
<blockquote>
<p>匿名对象只能使用一次</p>
</blockquote>
<ul>
<li>使用场景</li>
</ul>
<blockquote>
<p>当某个类的对象只需要使用一次的时候,就可以使用该类的匿名对象<br>例如:方法的参数,方法的返回值</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>在java中指的是“一个类”可以“继承自”“另一个类”。 “被继承的类”叫做: 父类/超类/基类，”继承其他类的类”叫做:子类。继承后，“子类”中就“拥有”了“父类”中所有的成员(成员变量、成员方法)。 “子类就不需要再定义了”</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>优点</li>
</ul>
<blockquote>
<p>提高代码的复用性（减少代码冗余，相同代码重复利用）[将一些共性的属性,行为抽取到一个父类中]。<br>使类与类之间产生了关系(多态）。</p>
</blockquote>
<ul>
<li>特点</li>
</ul>
<blockquote>
<p>类只支持单继承</p>
<p>一个类只有一个父类，但可以有多个子类</p>
<p>支持多层继承</p>
</blockquote>
<h3 id="继承后成员访问规则"><a href="#继承后成员访问规则" class="headerlink" title="继承后成员访问规则"></a>继承后成员访问规则</h3><ul>
<li>构造方法不能被继承</li>
<li>父类的“私有<code>成员</code>”可以被子类继承，但子类不能直接访问。</li>
<li>当通过“子类”访问非私有成员时，先在子类中找，如果找到就使用子类的，找不到就继续去“父类”中找。</li>
</ul>
<p><code>继承父类**成员是全继承**(包括静态属性和静态方法【子类静态方法声明可与父类相同，但并非重写，添加Override会编译报错，静态方法与类绑定，并非与对象绑定，亦不是多态】)，访问成员只需要考虑**私有或者非私有**</code></p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>返回值类型，方法名和参数列表都相同。声明不变，重新实现。</p>
</blockquote>
<ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>方法重写是发生在子父类之间的关系。</p>
<p>子类方法重写父类方法，返回值类型、方法名和参数列表都要一模一样。</p>
<p>子类方法重写父类方法，必须要保证权限大于等于父类权限。访问权限从大到小: public protected (默认) private</p>
<p>使用@Override注解，检验是否重写成功，重写注解校验！</p>
</blockquote>
<h3 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>关键字的三种用法:</span><br><span class="line">     <span class="keyword">this</span>可以访问本类的成员变量: <span class="keyword">this</span>.成员变量         一般用来区分同名的成员变量和局部变量</span><br><span class="line">     <span class="keyword">this</span>可以访问本类的成员方法: <span class="keyword">this</span>.成员方法名(实参);   </span><br><span class="line">     <span class="keyword">this</span>可以访问本类的构造方法:</span><br><span class="line">          空参构造: <span class="keyword">this</span>();</span><br><span class="line">          有参构造: <span class="keyword">this</span>(实参);</span><br><span class="line">              注意:</span><br><span class="line">                   <span class="number">1.</span>只能在本类的构造方法中使用<span class="keyword">this</span>调用其他构造方法</span><br><span class="line">                   <span class="number">2.</span>在本类的构造方法中使用<span class="keyword">this</span>调用其他构造方法,必须放在该构造方法的第一行,否则会报错</span><br><span class="line">                   <span class="number">3.</span>两个构造方法不能使用<span class="keyword">this</span>同时相互调用</span><br><span class="line">                       </span><br><span class="line"><span class="keyword">super</span>关键字的三种用法:</span><br><span class="line">     <span class="keyword">super</span>可以访问父类的成员变量: <span class="keyword">super</span>.成员变量         一般用来区分父子类中同名的成员变量</span><br><span class="line">     <span class="keyword">super</span>可以访问父类的成员方法: <span class="keyword">super</span>.成员方法(实参);   一般用来在子类中访问父类的成员方法</span><br><span class="line">     <span class="keyword">super</span>可以访问父类的构造方法:</span><br><span class="line">          空参构造: <span class="keyword">super</span>();</span><br><span class="line">          有参构造: <span class="keyword">super</span>(实参);</span><br><span class="line">              注意:</span><br><span class="line">                 <span class="number">1.</span>子类的构造方法默认会调用父类的空参构造方法</span><br><span class="line">                 <span class="number">2.</span><span class="keyword">super</span>访问父类的构造方法,可以用来初始化从父类继承过来的属性</span><br><span class="line">                 <span class="number">3.</span>在子类的构造方法中,使用<span class="keyword">super</span>调用父类的构造方法,必须放在子类构造方法的第一行</span><br><span class="line"> </span><br><span class="line">*<span class="keyword">super</span>注意事项：</span><br><span class="line">     <span class="keyword">super</span>访问成员变量和成员方法: 优先去父类中找,如果有就直接使用,如果没有就去爷爷类中找,如果有,就用,依次类推...</span><br><span class="line">     子类的构造方法默认会调用父类的空参构造方法,如果父类中的没有空参构造方法,只定义了有参构造方法,会编译报错</span><br><span class="line">     子类构造方法中使用<span class="keyword">super</span>调用父类的构造方法,是为了在创建子类对象的时候,初始化从父类继承过来的属性</span><br></pre></td></tr></table></figure>

<h3 id="继承体系对象的内存图"><a href="#继承体系对象的内存图" class="headerlink" title="继承体系对象的内存图"></a>继承体系对象的内存图</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>继承体系内存图原理—父类空间优先于子类对象产生。在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png"
                      alt="Java继承体系创建对象的内存图"
                ></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>使用abstract关键字修饰的类就是抽象类</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类可以拥有的成员</span></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：public可以省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>特点</li>
</ul>
<blockquote>
<p>抽象类不可以创建对象，主要用于子类继承</p>
<p>抽象类可以有构造方法，子类继承时可调用构造方法用于初始化</p>
<p>抽象类中可以没有抽象方法，抽象方法必须定义在抽象类中</p>
<p>子类继承抽象类后，必须重写抽象类中的所有抽象方法，否则子类必须也是一个抽象类</p>
</blockquote>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>没有方法体,使用abstract修饰的方法就是抽象方法</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(形参列表);</span><br><span class="line">例如:</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用场景与作用</li>
</ul>
<blockquote>
<p>抽象方法的使用场景:如果父类中某个方法,所有子类都有不同的实现,那么就可以把该方法定义为抽象方法</p>
<p>抽象方法的作用: 强制要求子类重写</p>
</blockquote>
<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>针对某些情况,在父类中指定一个模板,然后根据具体情况,在子类中灵活的具体实现该模板</p>
</blockquote>
<ul>
<li>实现步骤</li>
</ul>
<blockquote>
<p>1、定义抽象父类作为模板<br>2、在父类中定义”模板方法”— 已实现方法(通用模板)+抽象方法(填充模板)<br>3、子类继承父类,重写抽象方法(填充父类的模板)<br>4、测试类:创建子类对象，通过子类调用父类的“实现的方法”+ “子类重写后的方法”</p>
</blockquote>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>不可改变。可以用于修饰类、方法和变量。</p>
</blockquote>
<blockquote>
<p>类：被修饰的类，不能被继承。<br>方法：被修饰的方法，不能被重写。<br>变量：被修饰的变量（变量名全大写），就只能赋值一次,不能被重新赋值。</p>
</blockquote>
<p><code>例如public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code></p>
<ul>
<li><p><code>final修饰变量</code></p>
<p>局部变量</p>
<blockquote>
<p>基本类型：只能赋值一次，不能再更改。</p>
<p>引用类型：只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改</p>
</blockquote>
<p>成员变量</p>
<blockquote>
<p>成员变量涉及到初始化的问题，初始化方式有两种</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、显示初始化；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalVariable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、构造方法初始化。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalVariable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NUM2;</span><br><span class="line">    <span class="comment">// 所有的构造方法都要涵盖对final修饰的成员变量初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalVariable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.NUM2 = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalVariable</span><span class="params">(<span class="keyword">int</span> NUM2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.NUM2 = NUM2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>static是一个静态修饰符关键字,可以修饰成员变量和成员方法以及代码块。</p>
</blockquote>
<ul>
<li>使用</li>
</ul>
<p>static修饰成员变量</p>
<blockquote>
<p>类名.静态成员变量名，被static修饰的变量会被该类的所有对象共享</p>
</blockquote>
<p>static修饰成员方法</p>
<blockquote>
<p>类名.方法名(实参);</p>
</blockquote>
<ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>静态方法中不能出现this关键字</p>
<p>静态方法中只能直接访问静态成员变量和静态成员方法</p>
<p>非静态方法中可以直接访问一切成员变量和成员方法</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84static%E5%86%85%E5%AD%98%E5%9B%BE.png"
                      alt="static内存图"
                ></p>
<h2 id="day03-接口、多态、内部类"><a href="#day03-接口、多态、内部类" class="headerlink" title="day03 _接口、多态、内部类"></a>day03 _接口、多态、内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>接口是Java语言中的一种引用类型，是方法的”集合”，所以接口的内部主要就是定义方法</p>
</blockquote>
<ul>
<li>定义</li>
</ul>
<blockquote>
<p>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 常量(jdk7及其以前)</span></span><br><span class="line">    <span class="comment">// 抽象方法(jdk7及其以前)</span></span><br><span class="line">    <span class="comment">// 默认方法(jdk8)</span></span><br><span class="line">    <span class="comment">// 静态方法(jdk8)</span></span><br><span class="line">    <span class="comment">// 私有方法(jdk9)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>引用数据类型：数组，类，接口。</code></p>
<ul>
<li>特点</li>
</ul>
<blockquote>
<p>接口不能创建对象，需要实现类（子类）实现接口，并重写所有抽象方法，否则为抽象类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    接口成员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk7及以前====：常量、抽象方法</span></span><br><span class="line">    <span class="comment">// 常量:使用public static final修饰，可省略</span></span><br><span class="line">    <span class="keyword">int</span> NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法：使用public abstract修饰，可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk8====：默认方法、静态方法</span></span><br><span class="line">    <span class="comment">// 默认方法：使用public default修饰，public可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;default m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法: 使用public static修饰，public可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk9====：私有方法</span></span><br><span class="line">    <span class="comment">// 私有静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private static m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private 非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口中成员访问特点"><a href="#接口中成员访问特点" class="headerlink" title="接口中成员访问特点"></a>接口中成员访问特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">int</span> NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m4();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;default m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m5();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;static m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法:供本接口调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private static m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Imp</span> <span class="keyword">implements</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Imp IA abstract m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Imp IA default m...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        常量：**主要**供接口名直接访问，也可以被以实现类(抽象类和子类接口或者实现类)形式访问</span></span><br><span class="line"><span class="comment">        抽象方法：供实现类重写</span></span><br><span class="line"><span class="comment">        默认方法：供实现类重写或实现类对象调用。default标识接口方法体</span></span><br><span class="line"><span class="comment">        静态方法：**仅仅**供接口直接调用，这一点与类不同(详细见继承)</span></span><br><span class="line"><span class="comment">        私有方法：仅仅供本接口调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(IA.NUM);</span><br><span class="line"></span><br><span class="line">        Imp imp = <span class="keyword">new</span> Imp();</span><br><span class="line">        imp.m1();</span><br><span class="line">        imp.m2();</span><br><span class="line">        IA.m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多实现时的几种冲突"><a href="#多实现时的几种冲突" class="headerlink" title="多实现时的几种冲突"></a>多实现时的几种冲突</h3><blockquote>
<p>公有静态常量的冲突:实现类不继承冲突的常量<br>公有抽象方法的冲突:实现类只需要重写一个<br>公有默认方法的冲突:实现类必须重写一次最终版本<br>公有静态方法的冲突:静态方法是直接属于接口的,不能被继承,所以不存在冲突<br>私有方法的冲突:私有方法只能在本接口中直接使用,不存在冲突</p>
</blockquote>
<h3 id="接口与接口之间的关系"><a href="#接口与接口之间的关系" class="headerlink" title="接口与接口之间的关系"></a>接口与接口之间的关系</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>接口可以“继承”自另一个“接口”，而且可以“多继承”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IB</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IC</span> <span class="keyword">extends</span> <span class="title">IA</span>,<span class="title">IB</span></span>&#123;<span class="comment">//是“继承”，而且可以“多继承”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口多继承时的冲突情况</li>
</ul>
<blockquote>
<p>公有静态常量的冲突:子接口无法继承父接口中冲突的常量<br>公有抽象方法的冲突:子接口只会继承一个有冲突的抽象方法<br>公有默认方法的冲突:子接口中必须重写一次有冲突的默认方法(注意要加default)<br>公有静态方法和私有方法的冲突:不冲突,因为静态方法是直接属于接口的,只能使用本接口直接访问,而私有方法只能在接口中访问,也没有冲突</p>
<p>面试题:<br>     实现类重写接口中的默认方法,不需要加default<br>        子接口重写父接口中的默认方法,必须加default</p>
</blockquote>
<h3 id="实现类继承父类又实现接口时的冲突"><a href="#实现类继承父类又实现接口时的冲突" class="headerlink" title="实现类继承父类又实现接口时的冲突"></a>实现类继承父类又实现接口时的冲突</h3><blockquote>
<p>公有静态常量的冲突:子类无法继承有冲突的常量<br>公有抽象方法的冲突:子类必须重写一次有冲突的抽象方法<br>公有默认方法的冲突:优先访问父类的(父类中此默认方法无default修饰)<br>公有静态方法的冲突:只会访问父类的静态方法<br>私有方法的冲突: 不存在冲突，无法直接访问</p>
</blockquote>
<h3 id="Note：继承和实现"><a href="#Note：继承和实现" class="headerlink" title="*Note：继承和实现"></a>*Note：继承和实现</h3><ul>
<li>继承</li>
</ul>
<blockquote>
<p>所有<strong>类</strong>成员变量和成员方法都可以被继承(接口不是类)<br>父类中的成员一定是所有子类共有的</p>
</blockquote>
<ul>
<li>实现</li>
</ul>
<blockquote>
<p>实现类只能继承抽象方法、默认方法、（常量也可以，一般使用接口直接访问）<br>接口直接访问常量、静态方法、私有方法（接口中）</p>
</blockquote>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>多态是继封装、继承之后，面向对象的第三大特性。是指同一行为，对于不同的对象具有多个不同表现形式。</p>
</blockquote>
<ul>
<li>前提条件</li>
</ul>
<blockquote>
<p>1继承或者实现【二选一】<br>2父类引用指向子类对象\接口引用指向实现类对象【格式体现】<br>3方法的重写【意义体现：不重写，无意义】</p>
</blockquote>
<h3 id="多态时访问成员的特点"><a href="#多态时访问成员的特点" class="headerlink" title="多态时访问成员的特点"></a>多态时访问成员的特点</h3><blockquote>
<p>成员变量:编译看父类,运行看父类(编译看左边,运行看左边)<br>成员方法:<br>   非静态方法:编译看父类,运行看子类(编译看左边,运行看右边)<br>   静态方法: 编译看父类,运行看父类(编译看左边,运行看左边)<br><code>结论:除了非静态方法是编译看父类,运行看子类,其余都是看父类</code></p>
<p>另外，private修饰的成员不可跨类。static修饰的成员不具有多态（继承处笔记有说明）</p>
</blockquote>
<h3 id="多态的几种表现形式"><a href="#多态的几种表现形式" class="headerlink" title="多态的几种表现形式"></a>多态的几种表现形式</h3><blockquote>
<p>普通父类多态：继承一个类</p>
<p>抽象父类多态：继承一个抽象类</p>
<p>父接口多态：实现接口</p>
</blockquote>
<h3 id="多态的几种应用场景"><a href="#多态的几种应用场景" class="headerlink" title="多态的几种应用场景"></a>多态的几种应用场景</h3><blockquote>
<p>作为变量：变量多态–意义不大【父类类型的变量指向子类类型的对象】</p>
<p>作为形参：形参多态–常用【方法形参类型为父类类型】</p>
<p>作为返回值：返回值多态–常用【返回值为父类类型】</p>
</blockquote>
<p><code>示例</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dog extends Animal; <span class="comment">// 略写</span></span><br><span class="line"></span><br><span class="line">Animal anl = <span class="keyword">new</span> Dog(); <span class="comment">// 变量多态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animal anl)</span></span>&#123;</span><br><span class="line">    anl.eat()；</span><br><span class="line">&#125;<span class="comment">// 形参多态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Animal <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">&#125;<span class="comment">// 返回值多态</span></span><br></pre></td></tr></table></figure>

<h3 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h3><blockquote>
<p><strong>好处</strong>:提高代码的复用性<br><code>弊端:无法访问子类独有的方法或者成员变量【此弊端可以使用向下转型解决】,因为多态成员访问的特点是,编译看父类，以父类引用调用子类独有编译报错</code></p>
</blockquote>
<h3 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h3><ul>
<li>向上转型:可形成多态</li>
<li>向下转型:可解决多态弊端</li>
</ul>
<p><code>注意: 1.向下转型的时候:右边父类类型的变量一定要指向要转型的子类类型的对象 2.不管是向上转型还是向下转型,一定满足父子类关系或者实现关系</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用向下转型解决弊端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat fish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat playing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpOrDownT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// up casting,default to execute</span></span><br><span class="line">        Animal anl = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="comment">// anl.play(); // compile err</span></span><br><span class="line">        anl.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// down casting</span></span><br><span class="line">        Cat cat = (Cat) anl;</span><br><span class="line">        cat.eat();</span><br><span class="line">        cat.play();</span><br><span class="line">        System.out.println(cat.a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// compile normal,runtime err</span></span><br><span class="line">        Animal anl2 = <span class="keyword">new</span> Animal();</span><br><span class="line">        <span class="comment">// java.lang.ClassCastException: Animal cannot be cast to Cat</span></span><br><span class="line">        Cat cat2 = (Cat) anl2; <span class="comment">//anl2, parent class reference does not point to child class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>instanceof关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (anl <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">		Dog  d = (Dog)anl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决多态弊端和多态的综合示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特有的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在看家...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特有的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m(<span class="keyword">new</span> Dog());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(Animal anl)</span> </span>&#123;</span><br><span class="line">        anl.eat();</span><br><span class="line">        <span class="keyword">if</span> (anl <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            ((Dog) anl).lookHome();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anl <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            ((Cat) anl).catchMouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类<span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> 内部类<span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new A().new B();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问特点</li>
</ul>
<blockquote>
<p>内部类可以直接访问外部类的成员，包括私有成员。<br>外部类要访问内部类的成员，必须要创建内部类的对象。</p>
</blockquote>
<p><code>*外部类加载进入内存不会加载内部类,所以有如上规则.另只有静态内部类可以存在静态成员,非静态内部类不可以存在静态成员</code></p>
<p><code>*方法外部定义的内部类可以以public修饰，可有多个public修饰的内部类;内部类可以访问外部private成员</code></p>
<p><code>*观察Java编译器编译后的.class文件可以发现，Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.B.m();</span></span><br></pre></td></tr></table></figure>
<p>*Note:<a class="link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/3ec6aa56fe6a" >Java中四种内部类<i class="fas fa-external-link-alt"></i></a></p>
<p><code>四种内部类：成员内部类、局部内部类(不可添加类修饰符)、静态内部类、匿名内部类</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// member innert class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> price = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;car ing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;outer class private method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">double</span> price = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;engine is turning on&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// inner class can use outer class private members.</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> InnerClass().<span class="function">new <span class="title">Car</span><span class="params">()</span>.price)</span>;</span><br><span class="line">                drive();</span><br><span class="line">                m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// more public inner class(uninclude local inner class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClass.Car car = <span class="keyword">new</span> InnerClass().<span class="function">new <span class="title">Car</span><span class="params">()</span></span>;</span><br><span class="line">        InnerClass.Car.Engine engine = <span class="keyword">new</span> InnerClass().<span class="function">new <span class="title">Car</span><span class="params">()</span>.new <span class="title">Engine</span><span class="params">()</span></span>;</span><br><span class="line">        engine.m2();</span><br><span class="line"></span><br><span class="line">        InnerClass.Car.Engine engine1 = car.<span class="function">new <span class="title">Engine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        InnerClassT.B.m3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// anonymous inner class</span></span><br><span class="line">        <span class="keyword">new</span> InterT() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;anonymous inner class: interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.m1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// anonymous inner class</span></span><br><span class="line">        <span class="keyword">new</span> InterTA() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;anonymous inner class:abstract&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.m1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static inner class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// local inner class</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            C c = <span class="keyword">new</span> C();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>是内部类的简化写法。它的本质是一个<code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的 </code><strong>子类对象</strong>。</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> Animal() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).eat();</span><br><span class="line"></span><br><span class="line">        (<span class="keyword">new</span> IA() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).show();</span><br><span class="line"></span><br><span class="line">        m(<span class="keyword">new</span> Animal() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(Animal anl)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用类型使用小结"><a href="#引用类型使用小结" class="headerlink" title="引用类型使用小结"></a>引用类型使用小结</h3><blockquote>
<p>类名作为方法参数和返回值:可以直接传入该类的对象;返回该类的对象<br>抽象类作为方法参数和返回值:只能传入该类的子类对象;返回该类的子类对象<br>接口作为方法参数和返回值:只能传入该接口的实现类对象;返回该接口的实现类对象<br>传递的都是地址值,返回的也是地址值</p>
</blockquote>
<blockquote>
<p>类作为成员变量 : 赋该类的对象<br>抽象类作为成员变量 ; 赋该类的子类对象<br>接口作为成员变量: 赋该接口的实现类对象</p>
</blockquote>
<h2 id="day04-String和StringBuilder以及集合入门"><a href="#day04-String和StringBuilder以及集合入门" class="headerlink" title="day04_String和StringBuilder以及集合入门"></a>day04_String和StringBuilder以及集合入门</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public final class String     implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</code></p>
<p>String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象</p>
</blockquote>
<ul>
<li>常用的构造方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public   String(char[] value, int offset, int count)</td>
<td>根据指定字符数组范围的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] bys)</td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public   String(byte[] bytes, int offset, int length)</td>
<td>根据指定字节数组范围的内容，来创建字符串对象</td>
</tr>
<tr>
<td>String s = “abc”;</td>
<td>直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
<ul>
<li><code>创建字符串对象两种方式的区别</code></li>
</ul>
<p>通过构造方法创建</p>
<blockquote>
<p>通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然字符串内容相同，但是地址值不同</p>
</blockquote>
<p>直接赋值方式创建</p>
<blockquote>
<p>以””方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护(是常量,在常量池中,只有一份)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造方法创建</span></span><br><span class="line"><span class="keyword">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(chs);<span class="comment">// s1字符串的内容: abc</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(chs);<span class="comment">// s2字符串的内容: abc</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 比较s1和s2的地址值 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值方式创建</span></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">// str1字符串的内容: abc</span></span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;<span class="comment">// str2字符串的内容: abc</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">// 比较str1和str2的地址值 true</span></span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java_String%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB.png"
                      alt="String构造方法和直接赋值创建字符串的区别"
                ></p>
<h3 id="String类的特点"><a href="#String类的特点" class="headerlink" title="String类的特点"></a>String类的特点</h3><ul>
<li>String类的字符串不可变，它们的值在创建后不能被更改</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1 += <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(s1); <span class="comment">// &quot;abcd&quot; </span></span><br><span class="line"><span class="comment">// 内存中有&quot;abc&quot;，&quot;abcd&quot;,&quot;d&quot;,3个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>虽然 String 的值是不可变的，但是它们可以被共享</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串效果上相当于字符数组( char[] )</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如： </span><br><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">相当于： </span><br><span class="line"><span class="keyword">char</span>[] data = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;     </span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">// String底层是靠字符数组实现的,jdk9底层是字节数组。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(bys);</span><br></pre></td></tr></table></figure>

<h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><ul>
<li>==号的比较</li>
</ul>
<blockquote>
<p>基本数据类型：比较的是具体的值</p>
<p>引用数据类型：比较的是对象地址值</p>
</blockquote>
<ul>
<li>equals方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object s)</span>     <span class="comment">//比较两个字符串内容是否相同、区分大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(String anotherString)</span> <span class="comment">//将此字符串与指定对象进行比较，忽略大小写。</span></span></span><br></pre></td></tr></table></figure>

<h3 id="String类获取功能的方法"><a href="#String类获取功能的方法" class="headerlink" title="String类获取功能的方法"></a>String类获取功能的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span> ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span> ：将指定的字符串连接到该字符串的末尾。拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span> <span class="params">(<span class="keyword">int</span> index)</span> ：返回指定索引处的<span class="keyword">char</span>值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span> ：返回指定子字符串第一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>  返回从指定索引位置查找,该子字符串第一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> 返回指定子字符串最后一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> 返回从指定索引位置反向<span class="params">(backward)</span>查找,该子字符串最后一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex)</span> ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</span></span><br></pre></td></tr></table></figure>



<h3 id="String类判断功能的方法"><a href="#String类判断功能的方法" class="headerlink" title="String类判断功能的方法"></a>String类判断功能的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">//判断字符串是否为空(长度为0返回true，不为0返回false)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span>;    <span class="comment">//判断字符串中是否包含 给定的字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String s)</span></span>; <span class="comment">//判断字符串是否以 给定的字符串 结尾。可用于判断文件类型</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String s)</span></span>; <span class="comment">//判断字符串是否以给定的字符串 开头。</span></span><br><span class="line">	注意:<span class="keyword">null</span>不能调用方法,如果调用了就会报空指针异常NullPointerException</span><br></pre></td></tr></table></figure>



<h3 id="String类转换功能和其他功能的方法"><a href="#String类转换功能和其他功能的方法" class="headerlink" title="String类转换功能和其他功能的方法"></a>String类转换功能和其他功能的方法</h3><p><code>**注意返回一个新的字符串**</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar,<span class="keyword">char</span> newChar)</span></span>; <span class="comment">//用新内容替代旧内容，返回新的字符串，</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence oldStr,CharSequence newStr)</span></span>; <span class="comment">//用新内容替代旧内容，返回新的字符串，CharSequence是String的父接口</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;  <span class="comment">//把字母都转成其对应的小写形式。</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;  <span class="comment">//把字母都转成其对应的大写形式。</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray() <span class="comment">// 把字符串转换为数组</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes() <span class="comment">// 把字符串转换为字节数组</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;            <span class="comment">//移除首尾空格。</span></span><br><span class="line">String[] split(String regex);   <span class="comment">//根据给定的内容，切割字符串，返回字符串数组</span></span><br><span class="line">	参数regex: 分割的规则(普通的字符串,也可以是特殊的字符串(正则表达式))</span><br></pre></td></tr></table></figure>



<p>理解的口诀:</p>
<blockquote>
<p>判断功能  首尾中空加判断<br>获取功能  截长取位取元素<br>转换功能  大小拼串转数组 //toCharArray(), getBytes();<br>其他功能  除空切换字典拍 //copareTo();</p>
</blockquote>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public final class StringBuilder     extends AbstractStringBuilder     implements java.io.Serializable, CharSequence</code></p>
<p>StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的</p>
</blockquote>
<ul>
<li>StringBuilder类和String类的区别</li>
</ul>
<blockquote>
<p>String类：内容是不可变的,<strong>拼接耗时，又浪费空间</strong><br>StringBuilder类：内容是可变的</p>
</blockquote>
<ul>
<li>常用的构造方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder()</td>
<td>创建一个空白可变字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public StringBuilder(String str)</td>
<td>根据字符串的内容，来创建可变字符串对象</td>
</tr>
</tbody></table>
<h3 id="StringBuilder类常用方法"><a href="#StringBuilder类常用方法" class="headerlink" title="StringBuilder类常用方法"></a>StringBuilder类常用方法</h3><p><code>StringBuilder与String很相似，所以有很多类似方法；但StringBuilder操作对象后会返回本身(return this)，而String是返回新对象，这也是StringBuilder的优点</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(任意类型)</span> 拼接数据，并返回对象本身</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, 任意类型)</span> 在指定位置插入数据,并返回对象本身</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">reverse</span><span class="params">()</span>  反转字符串,并返回对象本身</span></span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder-⇋-String"><a href="#StringBuilder-⇋-String" class="headerlink" title="StringBuilder  ⇋  String"></a>StringBuilder  ⇋  String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span></span>;  String---&gt;<span class="function">StringBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;    StringBuilder---&gt;String</span><br><span class="line">    <span class="comment">// new String(StringBuilder sb)</span></span><br></pre></td></tr></table></figure>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>集合其实就是一个大小可变的容器,可以用来存储多个引用数据类型的数据</p>
</blockquote>
<ul>
<li>集合与数组的区别</li>
</ul>
<blockquote>
<p>数组：数组大小固定<br>集合：集合大小可动态扩展</p>
</blockquote>
<h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;         implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></p>
<p>ArrayList类底层是一个大小可变的数组实现</p>
</blockquote>
<ul>
<li>构造方法</li>
</ul>
<blockquote>
<p>public ArrayList() 构造一个初始容量为 10 的空列表。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;E&gt;();</span><br><span class="line"><span class="comment">// 如果未指定&lt;E&gt;泛型，则会创建泛型为Object的ArrayList集合对象。</span></span><br><span class="line">ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>



<h3 id="ArrayList类的方法"><a href="#ArrayList类的方法" class="headerlink" title="ArrayList类的方法"></a>ArrayList类的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>：将指定的元素追加到此集合的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span>：在此集合中的指定位置插入指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> 删除指定的元素，返回删除是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> 删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> 修改指定索引处的元素，返回被修改的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> 返回指定索引处的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> 返回集合中的元素的个数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// IndexOutOfBoundsException索引越界异常,需要注意index &lt; size</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">2</span>; <span class="comment">// 自动装箱 基本数据类型 --&gt;包装类</span></span><br><span class="line"><span class="keyword">int</span> c = a; <span class="comment">// 自动拆箱 包装类 --&gt;基本数据类型</span></span><br></pre></td></tr></table></figure>

<h2 id="day05-权限修饰符、代码块、常用API"><a href="#day05-权限修饰符、代码块、常用API" class="headerlink" title="day05_权限修饰符、代码块、常用API"></a>day05_权限修饰符、代码块、常用API</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>（空的）</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中(子类与无关类)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>编写代码时，如果没有特殊的考虑，建议这样使用权限：</code></p>
<blockquote>
<p>成员变量使用private ，隐藏细节。</p>
<p>构造方法使用public ，方便创建对象。</p>
<p>成员方法使用public ，方便调用方法。</p>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote>
<p>构造代码块 静态代码块 局部代码块</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        格式: &#123;&#125;</span></span><br><span class="line"><span class="comment">        位置: 类中,方法外</span></span><br><span class="line"><span class="comment">        执行: 每次在调用构造方法的时候,就会执行</span></span><br><span class="line"><span class="comment">        使用场景: 统计创建了多少个该类对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        格式:static&#123;&#125;</span></span><br><span class="line"><span class="comment">        位置: 类中,方法外</span></span><br><span class="line"><span class="comment">        执行: 当类被加载的时候执行,并只执行一次</span></span><br><span class="line"><span class="comment">        使用场景: 例如加载驱动,这种只需要执行一次的代码就可以放在静态代码块中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        执行优先级:  静态代码块 &gt;  构造代码块  &gt;  构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            格式:&#123;&#125;</span></span><br><span class="line"><span class="comment">            位置: 方法中</span></span><br><span class="line"><span class="comment">            执行: 调用方法,执行到局部代码块的时候就执行</span></span><br><span class="line"><span class="comment">            使用场景: 节省内存空间,没有多大的意义</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(num1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">静态代码块</span><br><span class="line">构造代码块</span><br><span class="line">构造方法</span><br><span class="line">构造代码块</span><br><span class="line">构造方法</span><br><span class="line">局部代码块</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码块特点遵循正常逻辑，如static</span></span><br></pre></td></tr></table></figure>

<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class Object</code></p>
<p>Object类当中包含的方法有11个,今天学习其中的2个</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>：返回该对象的字符串表示。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：指示其他某个对象是否与此对象“相等”。</span></span><br><span class="line"><span class="function">    Object类的equals方法默认比较的是2个对象的地址值是否相同  </span>== 一样的效果</span><br></pre></td></tr></table></figure>

<h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashCode、返回对象的字符串表示形式、比较两个对象。</p>
</blockquote>
<blockquote>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="native方法"><a href="#native方法" class="headerlink" title="native方法"></a>native方法</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>在Object类的源码中定义了 native 修饰的方法， native 修饰的方法称为本地方法。这种方法是没有方法体的,我们查看不了它的实现,当我们需要访问C或C++的代码时，或者访问操作系统的底层类库时，可以使用本地方法实现。</p>
<p>也就意味着Java可以和其它的编程语言进行交互。</p>
<p>本地方法的作用： 就是当Java调用非Java代码的接口。方法的实现由非Java语言实现，比如C或C++。</p>
</blockquote>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class Date     implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;</code></p>
<p><code>java.util.Date</code>类表示一个<strong>计算机本地系统的</strong>瞬时日期和时间，内部精确到毫秒。</p>
</blockquote>
<ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> : 创建当前系统时间对应的日期对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span>: 创建以标准基准时间为基准 指定偏移毫秒数 对应时间的日期对象</span></span><br><span class="line"><span class="function">	标准基准时间:</span></span><br><span class="line"><span class="function">			0时区: 1970年1月1日00:00:00 GMT</span></span><br><span class="line"><span class="function">             东8区: 1970年1月1日08:00:00 CST</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> 获取当前日期对象距离标准基准时间的毫秒值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span> 设置当前日期对象距离标准基准时间的毫秒值.也就意味着改变了当前日期对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">after</span><span class="params">(Date when)</span> 测试此日期是否在指定日期之后。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Date when)</span> 测试此日期是否在指定日期之前。</span></span><br></pre></td></tr></table></figure>

<h3 id="DateFormat类-SimpleDateFormat"><a href="#DateFormat类-SimpleDateFormat" class="headerlink" title="DateFormat类(SimpleDateFormat)"></a>DateFormat类(SimpleDateFormat)</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public abstract class DateFormat extends Format</code></p>
<p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,Date对象 ⇋ String对象</p>
</blockquote>
<blockquote>
<p><code>特点:由于DateFormat是抽象类无法创建对象,所以只能使用其子类SimpleDateFormat</code></p>
</blockquote>
<ul>
<li>SimpleDateFormat构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。</span></span><br><span class="line"><span class="function"><span class="comment">// 注意 SimpleDateFormat 不是线程安全，一个线程使用它没有并发问题</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>DateFormat类的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(Date date)</span>：将Date对象格式化为字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span>：将字符串解析为Date对象。</span></span><br><span class="line"><span class="function">    <span class="comment">// 需要处理解析异常</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">	常见的pattern用法</span></span></span><br><span class="line"><span class="comment"><span class="function">	</span></span></span><br><span class="line"><span class="comment"><span class="function">    常见的日期格式:  yyyy年MM月dd日 HH时mm分ss秒</span></span></span><br><span class="line"><span class="comment"><span class="function">    常见的日期格式:  yyyy-MM-dd HH:mm:ss</span></span></span><br><span class="line"><span class="comment"><span class="function">    常见的日期格式:  yyyy-MM-dd</span></span></span><br><span class="line"><span class="comment"><span class="function">    常见的日期格式:  HH:mm:ss</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt;</code></p>
<p>java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。</p>
</blockquote>
<ul>
<li>获取GregorianCalendar对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接创建GregorianCalendar对象；</span><br><span class="line">通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象</span><br></pre></td></tr></table></figure>

<ul>
<li>Calendar类的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span>;获取当前时间的日历对象</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span> 获取某个字段的值。</span></span><br><span class="line"><span class="function">     参数field:表示获取哪个字段的值,可以使用Calender中定义的常量来表示</span></span><br><span class="line"><span class="function">         	Calendar.YEAR : 年</span></span><br><span class="line"><span class="function">            Calendar.MONTH ：月</span></span><br><span class="line"><span class="function">            Calendar.DAY_OF_MONTH：月中的日期</span></span><br><span class="line"><span class="function">            Calendar.HOUR：小时</span></span><br><span class="line"><span class="function">            Calendar.MINUTE：分钟</span></span><br><span class="line"><span class="function">            Calendar.SECOND：秒</span></span><br><span class="line"><span class="function">            Calendar.DAY_OF_WEEK：星期</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> value)</span>设置某个字段的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span>为某个字段增加/减少指定的值</span></span><br><span class="line"><span class="function">额外增加:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span>  使用给定的 Date 设置此 Calendar 的时间。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object when)</span> 判断当前日历对象的时间是否在指定日历对象时间之前</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">after</span><span class="params">(Object when)</span> 判断当前日历对象的时间是否在指定日历对象时间之后</span></span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public final class Math</code></p>
<p>Math类包含执行基本数字运算的方法。<br>它不能创建对象，它的构造方法被“私有”（private修饰）了。因为内部都是“静态方法”，通过“类名”直接调用即可。</p>
</blockquote>
<ul>
<li>Math类的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> 获取参数a的绝对值：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span> 向上取整  例如:3.14 向上取整4.0；-3.14向上取整-3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span> 向下取整 例如:3.14 向下取整3.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span>  获取a的b次幂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span> 四舍五入取整 例如:3.14 取整3  3.56 取整4</span>;-<span class="number">3.14</span>取整-<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  返回两个 <span class="keyword">int</span> 值中较大的一个。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  返回两个 <span class="keyword">int</span> 值中较小的一个。</span></span><br></pre></td></tr></table></figure>

<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public final class System</code></p>
<p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。</p>
</blockquote>
<ul>
<li>System类的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span> 终止当前运行的Java虚拟机，非零表示异常终止</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> 返回当前时间<span class="params">(以毫秒为单位)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> 拷贝数组中的元素到另一个数组,目标数组会被覆盖</span></span><br><span class="line"><span class="function">    <span class="comment">// 注意数组索引越界</span></span></span><br></pre></td></tr></table></figure>

<h3 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class BigInteger extends Number implements Comparable&lt;BigInteger&gt;</code></p>
<p>java.math.BigInteger 类，不可变的任意精度的整数。如果运算中，数据的范围超过了long类型后，可以使用BigInteger类实现，该类的计算整数是不限制长度的。</p>
</blockquote>
<ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigInteger</span><span class="params">(String val)</span> 将十进制字符串形式转换为 BigInteger。超过<span class="keyword">long</span>类型的范围，已经不能称为数字了，因此构造方法中采用字符串的形式来表示超大整数，将超大整数封装成BigInteger对象。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>成员方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">(BigInteger value)</span>	返回其值为 <span class="params">(<span class="keyword">this</span> + val)</span> 的 BigInteger，超大整数加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">subtract</span><span class="params">(BigInteger value)</span>	返回其值为 <span class="params">(<span class="keyword">this</span> - val)</span> 的 BigInteger，超大整数减法运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">multiply</span><span class="params">(BigInteger value)</span>	返回其值为 <span class="params">(<span class="keyword">this</span> * val)</span> 的 BigInteger，超大整数乘法运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">divide</span><span class="params">(BigInteger value)</span>	返回其值为 <span class="params">(<span class="keyword">this</span> / val)</span> 的 BigInteger，超大整数除法运算，**除不尽取整数部分**</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; </code></p>
<p>java.math.BigDecimal(类):提供了更加精准的数据计算方式。</p>
</blockquote>
<ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">double</span> val)	将<span class="keyword">double</span>类型的数据封装为BigDecimal对象</span><br><span class="line">BigDecimal(String val)	将 BigDecimal 的字符串表示形式转换为 BigDecimal</span><br><span class="line">    推荐使用第二种方式，第一种存在精度问题；</span><br></pre></td></tr></table></figure>

<ul>
<li>常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal value)</span>	加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal value)</span>	减法运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal value)</span>	乘法运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal value)</span>	除法运算</span></span><br><span class="line"><span class="function">注意：对于divide方法来说，如果除不尽的话，就会出现java.lang.ArithmeticException异常。此时可以使用divide方法的另一个重载方法；BigDecimal <span class="title">divide</span><span class="params">(BigDecimal divisor, <span class="keyword">int</span> scale, RoundingMode roundingMode)</span>:</span></span><br><span class="line"><span class="function">		divisor：除数对应的BigDecimal对象；</span></span><br><span class="line"><span class="function">         scale:精确的位数；</span></span><br><span class="line"><span class="function">         roundingMode取舍模式  RoundingMode枚举:RoundingMode.HALF_UP 四舍五入</span></span><br></pre></td></tr></table></figure>

<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class Arrays</code></p>
<p>java.util.Arrays类：该类包含用于操作数组的各种方法（如排序和搜索）</p>
</blockquote>
<p>*Note:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(a); <span class="comment">// [I@75b84c92</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="keyword">char</span>[] chs = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">System.out.println(chs); <span class="comment">// 12a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是因为其他数组向上转型为Object对象，调用obj.toString输出地址；而char[]有单独实现输出行为,即使数组属于引用类型。可查看println源码。</span></span><br></pre></td></tr></table></figure>



<ul>
<li>Arrays类常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>：按照数字顺序排列指定的数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span>：返回指定数组的内容的字符串表示形式</span></span><br></pre></td></tr></table></figure>

<h3 id="包装类之Integer类"><a href="#包装类之Integer类" class="headerlink" title="包装类之Integer类"></a>包装类之Integer类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>此处以Integer介绍,其他包装类类似</p>
</blockquote>
<ul>
<li>Integer类构造方法及静态方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建或获取Integer对象实例：构造方法，静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span>	根据 <span class="keyword">int</span> 值创建 Integer 对象<span class="params">(过时)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span>	根据 String 值创建 Integer 对象<span class="params">(过时)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span>	返回表示指定的 <span class="keyword">int</span> 值的 Integer 实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span>	返回保存指定String值的 Integer 实例</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException 返回<span class="keyword">int</span>基本数据类型,除了Character其他基本数据类型包装类都具有此方法<span class="title">parseXxx</span><span class="params">(String s)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>装箱拆箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">2</span>; <span class="comment">// 自动装箱 基本数据类型 --&gt;包装类</span></span><br><span class="line"><span class="keyword">int</span> c = a; <span class="comment">// 自动拆箱 包装类 --&gt;基本数据类型</span></span><br></pre></td></tr></table></figure>

<h3 id="基本类型-⇋-String"><a href="#基本类型-⇋-String" class="headerlink" title="基本类型 ⇋ String"></a>基本类型 ⇋ String</h3><ul>
<li>基本类型 =&gt; String</li>
</ul>
<blockquote>
<p>1、基本类型+ “”</p>
<p>2、String.valueOf(num)</p>
</blockquote>
<ul>
<li>String =&gt; 基本类型 </li>
</ul>
<blockquote>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span>：将字符串参数转换为对应的<span class="keyword">int</span>基本类型。</span></span><br></pre></td></tr></table></figure>

<h2 id="day06-综合练习"><a href="#day06-综合练习" class="headerlink" title="day06_综合练习"></a>day06_综合练习</h2><blockquote>
<p> 查看pdf</p>
</blockquote>
<h2 id="day07-Collection、List、泛型、数据结构"><a href="#day07-Collection、List、泛型、数据结构" class="headerlink" title="day07_Collection、List、泛型、数据结构"></a>day07_Collection、List、泛型、数据结构</h2><h3 id="Collection集合接口"><a href="#Collection集合接口" class="headerlink" title="Collection集合接口"></a>Collection集合接口</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; </code></p>
<p>是单列集合类的根接口，用于存储一系列符合某种规则的元素</p>
</blockquote>
<ul>
<li>单列集合常用类的继承体系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection集合:接口,是所有单列集合的顶层父接口,该集合中的方法可以被所有单列集合共享</span><br><span class="line">	List集合: 接口,元素可重复,元素有索引,元素存取有序</span><br><span class="line">		ArrayList集合: 实现类,查询快,增删慢</span><br><span class="line">		LinkedList集合: 实现类,查询慢,增删快</span><br><span class="line"></span><br><span class="line">	Set集合: 接口, 元素不可重复(唯一),元素无索引</span><br><span class="line">		HashSet集合: 实现类,元素存取无序</span><br><span class="line">		LinkedHashSet集合:实现类,元素存取有序</span><br><span class="line">		TreeSet集合:实现类,可以对集合中的元素进行排序</span><br></pre></td></tr></table></figure>



<ul>
<li>Collection集合常用方法</li>
</ul>
<blockquote>
<p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>： 把给定的对象添加到当前集合中 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> :清空集合中所有的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span>: 把给定的对象在当前集合中删除。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span>: 判断当前集合中是否包含给定的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>: 判断当前集合是否为空。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 返回集合中元素的个数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span>: 把集合中的元素，存储到数组中</span></span><br><span class="line"><span class="function"><span class="comment">// Collection集合提供了一个获取迭代器的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span>: 获取集合对应的迭代器，用来遍历集合中的元素的。</span></span><br></pre></td></tr></table></figure>

<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public interface Iterator&lt;E&gt;</code></p>
<p>即Collection集合元素的通用获取方式。</p>
</blockquote>
<ul>
<li>Iterator接口的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span>:返回迭代的下一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>:如果仍有元素可以迭代，则返回 <span class="keyword">true</span>。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span>: 迭代时进行删除*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>迭代器常见的2个问题</li>
</ul>
<blockquote>
<p>问题一:在进行集合元素获取时，如果集合中已经没有元素可以迭代了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。</p>
<p><strong>解决办法</strong>: 如果还需要重新迭代,那么就重新获取一个新的迭代器对象进行操作</p>
</blockquote>
<blockquote>
<p>问题二:在进行集合元素迭代时，如果添加或移除集合中的元素 ,将无法继续迭代 , 将会抛出ConcurrentModificationException并发修改异常.</p>
<p><strong>解决办法</strong>：使用Iterator提供的remove方法，参考编写如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it3.hasNext()) &#123;</span><br><span class="line">        String s = it3.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">// col2.add(&quot;d&quot;); // 异常</span></span><br><span class="line">        <span class="comment">// col2.remove(s); // 异常</span></span><br><span class="line">        <span class="comment">// 迭代时删除操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;a&quot;</span>.equals(s)) &#123;</span><br><span class="line">            it3.remove();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>理解</strong>: 迭代完成,无指向数据,所以不可以继续取数据;迭代时使用集合增删数据,会破坏迭代器的指向,所以不可以使用集合增删数据.</p>
</blockquote>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>泛型的作用是在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<ul>
<li>定义和使用含有泛型的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setE</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">test.setE(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(test.getE());</span><br></pre></td></tr></table></figure>

<ul>
<li>定义和使用含有泛型的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">m</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">m(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>定义和使用含有泛型的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> E <span class="title">m2</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imp</span> <span class="keyword">implements</span> <span class="title">IA</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">IA</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型类、方法、接口何时确定类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用含有泛型的类:  创建该类对象的时候,指定泛型的具体数据类型</span><br><span class="line">使用含有方向的方法: 调用该方法的时候,确定泛型的具体数据类型</span><br><span class="line">使用含有泛型的接口:</span><br><span class="line">	<span class="number">1.</span>创建实现类实现接口的时候,指定泛型的具体数据类型</span><br><span class="line">    <span class="number">2.</span>创建实现类实现接口的时候,不知道泛型的具体数据类型,而是创建实现类对象的时候指定泛型的具体数据类型</span><br></pre></td></tr></table></figure>

<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。<br><code>注意: 不能往该集合中存储数据,只能获取数据;泛型没有多态</code></p>
</blockquote>
<ul>
<li>受限泛型</li>
</ul>
<blockquote>
<p>上限: &lt;? extends 类名&gt;  只能接收该类类型或者其子类类型<br>下限: &lt;? super 类名&gt;   只能接收该类类型或者其父类类型</p>
</blockquote>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>栈</li>
</ul>
<blockquote>
<p>栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p>
<p><strong>特点</strong>:先进后出;栈的入口、出口的都是栈的顶端位置。</p>
</blockquote>
<ul>
<li>队列</li>
</ul>
<blockquote>
<p>队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行取出并删除。</p>
<p><strong>特点</strong>:先进先出;队列的入口、出口各占一侧。</p>
</blockquote>
<ul>
<li>数组</li>
</ul>
<blockquote>
<p>数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。</p>
<p><strong>特点</strong>:查找元素快：通过索引，可以快速访问指定位置的元素;增删元素慢(数组长度固定,需要创建新数组进行增删操作)</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9.png"
                      alt="数组结构的特点"
                ></p>
<ul>
<li>链表</li>
</ul>
<blockquote>
<p>链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p><strong>特点</strong>:多个结点之间，通过地址进行连接;查找元素慢:想查找某个元素，需要通过连接的节点，依次向后查找指定元素;增删元素快：只需要修改链接下一个元素的地址值即可</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9.png"
                      alt="链表结构的特点"
                ></p>
<ul>
<li>树</li>
</ul>
<blockquote>
<p>lue</p>
</blockquote>
<h3 id="List集合接口"><a href="#List集合接口" class="headerlink" title="List集合接口"></a>List集合接口</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public interface List&lt;E&gt; extends Collection&lt;E&gt;</code></p>
<p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法</p>
</blockquote>
<ul>
<li>List接口新增常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span>: 将指定的元素，添加到该集合中的指定位置上。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:返回集合中指定位置的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>: 移除列表中指定位置的元素, 返回的是被移除的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></span><br></pre></td></tr></table></figure>

<h3 id="List的子类"><a href="#List的子类" class="headerlink" title="List的子类"></a>List的子类</h3><ul>
<li>ArrayList</li>
</ul>
<blockquote>
<p>java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快</p>
</blockquote>
<ul>
<li>LinkedList</li>
</ul>
<blockquote>
<p>java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
</blockquote>
<p>LinkedList常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedList是一个双向链表,实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span>:从此列表所表示的堆栈处弹出一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span>:将元素推入此列表所表示的堆栈。</span></span><br></pre></td></tr></table></figure>

<h2 id="day08-Collections、Set、Map、排序"><a href="#day08-Collections、Set、Map、排序" class="headerlink" title="day08_Collections、Set、Map、排序"></a>day08_Collections、Set、Map、排序</h2><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public class Collections</code></p>
<p>java.utils.Collections是集合工具类，用来对集合进行操作</p>
</blockquote>
<ul>
<li>Collections常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span>:打乱集合顺序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span>:将集合中元素按照默认规则排序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list，Comparator&lt;? <span class="keyword">super</span> T&gt; )</span>:将集合中元素按照指定规则排序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; c, T... elements)</span>:往集合中添加一些元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>排序</li>
</ul>
<p><strong>按照默认规则排序</strong>:集合元素所属的类通过实现Comparable接口,重写compareTo(T o)方法写好排序规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定排序规则</span></span><br><span class="line">        <span class="comment">// 前减后  升序</span></span><br><span class="line">        <span class="comment">// 后减前  降序</span></span><br><span class="line">        <span class="comment">// 前:this  后: 参数o</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;<span class="comment">// 升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定规则排序</strong>:通过传入Comparator接口的匿名内部类,重写compare(T o1,T o2)方法指定排序规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list1, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getAge() - o1.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Note:</code></p>
<blockquote>
<p><strong>匿名对象</strong>:无指定名称的对象:new Test()</p>
<p><strong>匿名内部类</strong>:<code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的 </code><strong>子类对象</strong>:new IA(…)</p>
</blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>一个方法只能有一个可变参数</p>
<p>如果方法中有多个参数，可变参数要放到最后。</p>
</blockquote>
<h3 id="Set集合接口"><a href="#Set集合接口" class="headerlink" title="Set集合接口"></a>Set集合接口</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public interface Set&lt;E&gt; extends Collection&lt;E&gt;</code></p>
<p>接口, 元素不可重复(唯一),元素无索引</p>
</blockquote>
<ul>
<li>注意</li>
</ul>
<blockquote>
<p>Set集合没有特殊的方法,都是使用Collection接口的方法<br>Set集合没有索引,所以遍历元素的方式就只有: 增强for循环,或者迭代器</p>
</blockquote>
<h3 id="Set的子类"><a href="#Set的子类" class="headerlink" title="Set的子类"></a>Set的子类</h3><ul>
<li>HashSet</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">哈希表结构:</span><br><span class="line">	jdk8以前: 数组+链表</span><br><span class="line">	jdk8以后: 数组+链表+红黑树</span><br><span class="line">		链表元素个数没有超过<span class="number">8</span>: 数组+链表</span><br><span class="line">		链表元素个数超过<span class="number">8</span>: 数组+链表+红黑树</span><br><span class="line"></span><br><span class="line">HashSet集合保证元素唯一的原理--依赖存放自定义类型元素的hashCode()和equals()方法</span><br><span class="line">	<span class="number">1.</span>当存储元素的时候,就会调用该元素的hashCode()方法计算该元素的哈希值</span><br><span class="line">	<span class="number">2.</span>判断该哈希值对应的位置上,是否有元素:</span><br><span class="line">	<span class="number">3.</span>如果该哈希值对应的位置上,没有元素,就直接存储</span><br><span class="line">	<span class="number">4.</span>如果该哈希值对应的位置上,有元素,说明产生了哈希冲突</span><br><span class="line">	<span class="number">5.</span>产生了哈希冲突,就得调用该元素的equals方法,与该位置上的所有元素进行一一比较:</span><br><span class="line">		如果比较的时候,有任意一个元素与该元素相同,那么就不存储</span><br><span class="line">		如果比较完了,没有一个元素与该元素相同,那么就直接存储</span><br><span class="line"></span><br><span class="line">Object类: hashCode()和equals()方法;</span><br><span class="line">	hashCode():Object类中的hashCode()方法是根据地址值计算哈希值</span><br><span class="line">	equals方法():Object类中的equals()方法是比较地址值</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"
                      alt="哈希流程图"
                ></p>
<ul>
<li>LinkedHashSet</li>
</ul>
<blockquote>
<p>采用哈希表+链表结构，由哈希表保证元素唯一，由链表保证元素存取有序</p>
</blockquote>
<ul>
<li>TreeSet</li>
</ul>
<blockquote>
<p>TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于红黑树的实现</p>
</blockquote>
<blockquote>
<p><strong>特点</strong>:元素唯一<br>        元素没有索引<br>        使用元素的自然顺序对元素进行排序，或者根据创建 TreeSet 时提供的         Comparator 比较器进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span>：						  根据其元素的自然排序进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;E&gt; comparator)</span>:    根据指定的比较器进行排序</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Map集合接口"><a href="#Map集合接口" class="headerlink" title="Map集合接口"></a>Map集合接口</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public interface Map&lt;K,V&gt; </code></p>
</blockquote>
<ul>
<li>特点</li>
</ul>
<blockquote>
<p>Map集合存储元素是以键值对的形式存储,每一个键值对都有键和值<br>Map集合的键是唯一,值可以重复,如果键重复了,那么值就会被覆盖<br>根据键取值</p>
</blockquote>
<ul>
<li>Map集合常用类的继承体系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。</span><br><span class="line">	由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</span><br><span class="line">LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。</span><br><span class="line">	通过链表结构可以保证键值对的存取顺序一致；</span><br><span class="line">	通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</span><br><span class="line">TreeMap&lt;K,V&gt;：TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；</span><br><span class="line">	可以对元素的键进行排序，排序方式有两种:自然排序和比较器排序</span><br></pre></td></tr></table></figure>

<ul>
<li>Map集合常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span>: 把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> 根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>:集合中键值对的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>:判断该集合中是否有此键</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>:判断该集合中是否有此值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span>: 获取Map集合中所有的键，存储到Set集合中</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span>: 获取Map集合中所有的值，存储到Collection集合中<span class="params">(值有重复)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span>: 获取到Map集合中所有的键值对对象的集合<span class="params">(Set集合)</span>。</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Map集合遍历</li>
</ul>
<p>键找值方式</p>
<blockquote>
<p>1.获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset()<br>2.遍历键的Set集合，得到每一个键。<br>3.根据键，获取键所对应的值。方法提示:get(K key)</p>
</blockquote>
<p>键值对方式</p>
<blockquote>
<p>1.获取集合中所有键值对对象，以Set集合形式返回。  Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>2.遍历所有键值对对象的集合，得到每一个键值对(Entry)对象。<br>3.在循环中,可以使用键值对对对象获取键和值   getKey()和getValue()</p>
</blockquote>
<h3 id="Map的子类"><a href="#Map的子类" class="headerlink" title="Map的子类"></a>Map的子类</h3><p><code>参考Set的子类</code></p>
<ul>
<li>HashMap</li>
</ul>
<blockquote>
<p>根据键来进行存储,键产生哈希冲突会覆盖值</p>
</blockquote>
<ul>
<li><p>LinkedHashMap</p>
</li>
<li><p>TreeMap</p>
</li>
</ul>
<h2 id="day09-排序算法-异常-多线程基础"><a href="#day09-排序算法-异常-多线程基础" class="headerlink" title="day09_排序算法,异常,多线程基础"></a>day09_排序算法,异常,多线程基础</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是<strong>中断处理</strong>。</p>
</blockquote>
<ul>
<li>异常的根类Throwable的子类</li>
</ul>
<blockquote>
<p><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免</p>
<p><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的</p>
</blockquote>
<ul>
<li>异常分类</li>
</ul>
<blockquote>
<p><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)<code>java.lang.Exception</code><br><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)<code>java.lang.RuntimeException</code>,如NullPointerException、ArrayIndexOutOfBoundsException、ArithmeticException、ClassCastException</p>
</blockquote>
<h3 id="异常的产生和处理"><a href="#异常的产生和处理" class="headerlink" title="异常的产生和处理"></a>异常的产生和处理</h3><ul>
<li>异常的产生</li>
</ul>
<blockquote>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br><span class="line"><span class="comment">// Note:异常抛出后需要处理,声明或者捕获(运行时异常被抛出可以不处理,即不捕获也不声明抛出)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>声明处理异常</li>
</ul>
<blockquote>
<p>使用throws关键字将问题标识出来, 表示当前方法不处理异常，而是提醒给调用者, 让调用者来处理….最终会到虚拟机,虚拟机直接结束程序,打印异常信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>…&#123;  <span class="comment">// 可以抛出一个,也可以多个&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点</strong>: 声明处理异常,处理完后,<code>如果程序运行的时候出现异常,程序还是无法继续往下执行</code><br><strong>使用场景</strong>:  声明处理异常一般处理运行的时候不会出现异常的编译异常</p>
</blockquote>
<ul>
<li>捕获处理异常</li>
</ul>
<blockquote>
<p>对异常进行捕获处理 , 处理完后程序可以正常向下执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常出现停止此行及后续try语句执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;捕获异常执行后才会catch语句，如果遇到return，记住返回值，&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;执行finally语句，如果finally有return返回其中值并终止后续语句&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally语句，无return继续执行后续语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally后的语句&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>特点</strong>:<br>try和catch都不能单独使用,必须连用。<br>try中的代码出现了异常,那么出现异常位置后面的代码就不会再执行了<br><code>捕获处理异常,如果程序出现了异常,程序会继续往下执行</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能会出现异常的代码       </span><br><span class="line">&#125;<span class="keyword">catch</span>(异常的类型 变量名)&#123;</span><br><span class="line">    处理异常的代码或者打印异常的信息</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论异常是否发生,都会执行这里的代码(正常情况,都会执行<span class="keyword">finally</span>中的代码,一般用来释放资源)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行步骤:</span></span><br><span class="line">	<span class="number">1.</span>首先执行<span class="keyword">try</span>中的代码,如果<span class="keyword">try</span>中的代码出现了异常,那么就直接执行<span class="keyword">catch</span>()里面的代码,执行完后会执行<span class="keyword">finally</span>中的代码,然后程序继续往下执行</span><br><span class="line">	<span class="number">2.</span>如果<span class="keyword">try</span>中的代码没有出现异常,那么就不会执行<span class="keyword">catch</span>()里面的代码,但是还是会执行<span class="keyword">finally</span>中的代码,然后程序继续往下执行</span><br></pre></td></tr></table></figure>

<ul>
<li>获取异常信息</li>
</ul>
<blockquote>
<p>Throwable类中定义了一些查看方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>:获取异常的描述信息,原因<span class="params">(提示给用户的时候,就提示错误原因。</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">public</span> String toString()</span>:获取异常的类型和异常描述信息<span class="params">(不用)</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>:打印异常的跟踪栈信息并输出到控制台。</span></span><br></pre></td></tr></table></figure>

<h3 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException, IndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.如果父类的方法抛出了多个异常,子类覆盖(重写)父类方法时,只能抛出相同的异常或者是他的子集。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException, IndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// throw new Exception(&quot;&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            异常注意事项:</span></span><br><span class="line"><span class="comment">                1.运行时异常被抛出可以不处理。即不捕获也不声明抛出。</span></span><br><span class="line"><span class="comment">                2.如果父类的方法抛出了多个异常,子类覆盖(重写)父类方法时,只能抛出相同的异常或者是他的子集。</span></span><br><span class="line"><span class="comment">                3.父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</span></span><br><span class="line"><span class="comment">                4.声明处理多个异常,可以直接声明这多个异常的父类异常</span></span><br><span class="line"><span class="comment">                5.在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。</span></span><br><span class="line"><span class="comment">                6.多个异常使用捕获又该如何处理呢？</span></span><br><span class="line"><span class="comment">                    1. 多个异常分别处理。</span></span><br><span class="line"><span class="comment">                    2. 多个异常一次捕获，多次处理。</span></span><br><span class="line"><span class="comment">                    3. 多个异常一次捕获一次处理。</span></span><br><span class="line"><span class="comment">                7.当多异常分别处理时，捕获处理，前边的类不能是后边类的父类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.运行时异常被抛出可以不处理。即不捕获也不声明抛出。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.声明处理多个异常,可以直接声明这多个异常的父类异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show4</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;e&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.多个异常使用捕获又该如何处理呢？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show6</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;e&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show62</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;e&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show7</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show63</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">&quot;e&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="comment">/*catch (ParseException e) &#123;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>自定义一个<strong>编译期异常</strong>: 自定义类并继承于java.lang.Exception。<br>自定义一个<strong>运行时期异常类</strong>:自定义类并继承于java.lang.RuntimeException。</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>并发与并行</li>
</ul>
<blockquote>
<p><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时执行）。</p>
<p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生(交替执行)。</p>
</blockquote>
<ul>
<li>线程与进程</li>
</ul>
<blockquote>
<p><strong>进程</strong>：进程是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；</p>
<p><strong>线程</strong>：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
</blockquote>
<blockquote>
<p>多线程并行: 多条线程在同一时刻同时执行</p>
<p><strong>多线程并发:多条线程在同一时间段交替执行</strong></p>
</blockquote>
<blockquote>
<p><strong>在java中线程的调度是:抢占式调度</strong></p>
<p><strong>在java中只有多线程并发,没有多线程并行(高并发)</strong></p>
</blockquote>
<blockquote>
<p><strong>进程与线程的区别</strong></p>
<p>进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。<br>线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。</p>
</blockquote>
<ul>
<li>线程调度</li>
</ul>
<p>分时调度</p>
<blockquote>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</blockquote>
<p>抢占式调度</p>
<blockquote>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
</blockquote>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul>
<li><p>概述</p>
<blockquote>
<p><code>public class Thread implements Runnable</code></p>
<p>用于创建线程</p>
</blockquote>
<blockquote>
<p>Runnable:实现此接口的子类对象可以执行线程任务</p>
<p><code>public interface Runnable</code></p>
</blockquote>
</li>
<li><p>Thread类的构造方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span>:分配一个新的线程对象,线程名称是默认生成的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span>:分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span>:分配一个带有指定目标新的线程对象,线程名称是默认生成的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span>:分配一个带有指定目标新的线程对象并指定名字。</span></span><br><span class="line"><span class="function"><span class="comment">// Runnable: 接口,线程任务接口</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">创建线程的方式有2种:</span></span><br><span class="line"><span class="function">	一种是通过继承Thread类的方式,重写run方法,由Thread子类对象调用run</span></span><br><span class="line"><span class="function">	一种是通过实现Runnable接口的run方法,将实现类对象作为taget创建Thread对象，由Runable实现类对象调用run</span></span><br><span class="line"><span class="function">        <span class="comment">// 这可使用匿名内部类的方式实现Runnable接口</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">注意:</span></span><br><span class="line"><span class="function">	1.主线程一定会等子线程全部执行完毕才会结束主线程</span></span><br><span class="line"><span class="function">	2.子线程任务代码执行完毕,线程就会销毁</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Thread类的常用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span>:获取当前线程名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>:导致此线程开始执行</span>; JVM调用此线程的run方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>:此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="function">    	<span class="comment">// Thread类的run方法代码：</span></span></span><br><span class="line"><span class="function">        @Override</span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                target.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>:返回对当前正在执行的线程对象的引用。</span></span><br></pre></td></tr></table></figure>

<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><ul>
<li>实现Runnable接口比继承Thread类所具有的<strong>优势</strong></li>
</ul>
<blockquote>
<p>可以避免java中的单继承的局限性（继承Thread不可继承其他类）。<br>线程和任务代码是独立分块的,启动解耦操作<br>任务资源可以被多条线程共享（多条线程可共享一个Runable实现类对象）<br>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</p>
</blockquote>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p>synchronized关键字：表示“同步”的。将多行代码当成是一个完整的整体，一个线程如果进入到这个代码块中，会全部执行完毕，执行结束后，其它线程才会执行。</p>
<p>synchronized被称为“重量级的锁”方式，也是“悲观锁”——效率比较低。</p>
</blockquote>
<ul>
<li>synchronized的使用方式</li>
</ul>
<p>同步代码块及其锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            同步代码块:</span></span><br><span class="line"><span class="comment">                概述:synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</span></span><br><span class="line"><span class="comment">                格式:</span></span><br><span class="line"><span class="comment">                    synchronized(锁对象)&#123;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                锁对象:</span></span><br><span class="line"><span class="comment">                    1.语法上,锁对象可以是任意类的对象</span></span><br><span class="line"><span class="comment">                    2.多条线程想要实现同步,必须锁对象一致</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + tickets + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同步方法及其锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sellTickets()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    同步方法:</span></span><br><span class="line"><span class="comment">        概述:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</span></span><br><span class="line"><span class="comment">        格式:</span></span><br><span class="line"><span class="comment">        	修饰符 synchronized 返回值类型 方法名(形参列表)&#123;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        锁对象:</span></span><br><span class="line"><span class="comment">            非静态同步方法: 锁对象是this</span></span><br><span class="line"><span class="comment">            静态同步方法: 锁对象是该方法所在类的字节码对象(类名.class)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sellTickets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + tickets + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>开发中,一条线程使用的是同步代码块,一条线程使用的是同步方法,但这2条线程需要实现同步---&gt;实现这个需求,同步代码块和同步方法的锁对象必须一致,而同步方法的锁对象是默认的,所以必须清楚同步方法的锁对象</code></p>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><ul>
<li>概述</li>
</ul>
<blockquote>
<p><code>public interface Lock</code></p>
<p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更加面向对象，将加锁与释放锁进行了方法化。</p>
<p>一般使用实现类ReentrantLock</p>
</blockquote>
<ul>
<li>Lock的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>:加同步锁。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>:释放同步锁。</span></span><br></pre></td></tr></table></figure>

<h3 id="高并发及线程安全"><a href="#高并发及线程安全" class="headerlink" title="高并发及线程安全"></a>高并发及线程安全</h3><blockquote>
<p><strong>高并发</strong>：是指在某个时间点上，有大量的用户(线程)同时访问同一资源</p>
<p><strong>线程安全</strong>：在某个时间点上，当大量用户(线程)访问同一资源时，由于多线程运行机制的原因，可能会导致被访问的资源出现”数据污染”的问题。</p>
</blockquote>
<h3 id="多线程的运行机制"><a href="#多线程的运行机制" class="headerlink" title="多线程的运行机制"></a>多线程的运行机制</h3><ul>
<li><p>概述</p>
<blockquote>
<p>当一个线程启动后，JVM会为其分配一个独立的”线程栈区”，这个线程会在这个独立的栈区中运行。</p>
</blockquote>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png"
                      alt="Java多线程的运行机制"
                ></p>
<ul>
<li>问题</li>
</ul>
<blockquote>
<p>多个线程在各自栈区中独立、无序的运行，当访问一些代码，或者同一个变量时，就可能会产生一些问题</p>
</blockquote>
<h3 id="多线程的安全性问题"><a href="#多线程的安全性问题" class="headerlink" title="多线程的安全性问题"></a>多线程的安全性问题</h3>
        </div>

        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/08/18/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90%E6%A3%80%E7%B4%A2%E6%94%B6%E9%9B%86/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">文章资源检索收集</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2023&nbsp;<a href="/">oo</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E3%80%81JRE%E3%80%81JVM"><span class="nav-text">JDK、JRE、JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text">配置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-text">快速入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6"><span class="nav-text">进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">数据类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-text">方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6"><span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#day01-%E7%B1%BB%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">day01_类和面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-text">面向对象和面向过程编程思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">类和对象的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">类的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">对象的创建与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">成员变量默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-text">对象内存图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91"><span class="nav-text">成员变量和局部变量的区别【理解】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%B1%BB%E5%88%B6%E4%BD%9C"><span class="nav-text">标准类制作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API"><span class="nav-text">API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day02-%E9%9D%99%E6%80%81%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81final"><span class="nav-text">day02_静态、继承、模板设计模式、抽象类、final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8E%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="nav-text">继承后成员访问规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="nav-text">方法重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%92%8Csuper"><span class="nav-text">this和super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-text">继承体系对象的内存图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">模板设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">static关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day03-%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">day03 _接口、多态、内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="nav-text">接口中成员访问特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%97%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%B2%E7%AA%81"><span class="nav-text">多实现时的几种冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">接口与接口之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%8F%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%97%B6%E7%9A%84%E5%86%B2%E7%AA%81"><span class="nav-text">实现类继承父类又实现接口时的冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Note%EF%BC%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">*Note：继承和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%97%B6%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">多态时访问成员的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-text">多态的几种表现形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">多态的几种应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="nav-text">多态的好处和弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">引用类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93"><span class="nav-text">引用类型使用小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day04-String%E5%92%8CStringBuilder%E4%BB%A5%E5%8F%8A%E9%9B%86%E5%90%88%E5%85%A5%E9%97%A8"><span class="nav-text">day04_String和StringBuilder以及集合入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-text">String类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">String类的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">字符串的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">String类获取功能的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">String类判断功能的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%8A%9F%E8%83%BD%E5%92%8C%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">String类转换功能和其他功能的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder%E7%B1%BB"><span class="nav-text">StringBuilder类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">StringBuilder类常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder-%E2%87%8B-String"><span class="nav-text">StringBuilder  ⇋  String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E7%B1%BB"><span class="nav-text">ArrayList类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">ArrayList类的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day05-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%B8%B8%E7%94%A8API"><span class="nav-text">day05_权限修饰符、代码块、常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-text">Object类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objects%E7%B1%BB"><span class="nav-text">Objects类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#native%E6%96%B9%E6%B3%95"><span class="nav-text">native方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date%E7%B1%BB"><span class="nav-text">Date类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DateFormat%E7%B1%BB-SimpleDateFormat"><span class="nav-text">DateFormat类(SimpleDateFormat)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calendar%E7%B1%BB"><span class="nav-text">Calendar类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math%E7%B1%BB"><span class="nav-text">Math类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System%E7%B1%BB"><span class="nav-text">System类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigInteger%E7%B1%BB"><span class="nav-text">BigInteger类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigDecimal"><span class="nav-text">BigDecimal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays%E7%B1%BB"><span class="nav-text">Arrays类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8BInteger%E7%B1%BB"><span class="nav-text">包装类之Integer类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E2%87%8B-String"><span class="nav-text">基本类型 ⇋ String</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day06-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0"><span class="nav-text">day06_综合练习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day07-Collection%E3%80%81List%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">day07_Collection、List、泛型、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="nav-text">Collection集合接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">Iterator迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="nav-text">增强for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">泛型通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="nav-text">List集合接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="nav-text">List的子类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day08-Collections%E3%80%81Set%E3%80%81Map%E3%80%81%E6%8E%92%E5%BA%8F"><span class="nav-text">day08_Collections、Set、Map、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections%E7%B1%BB"><span class="nav-text">Collections类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="nav-text">Set集合接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="nav-text">Set的子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="nav-text">Map集合接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="nav-text">Map的子类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day09-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BC%82%E5%B8%B8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">day09_排序算法,异常,多线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-text">异常的产生和处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">异常注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB"><span class="nav-text">Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Thread和Runnable的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E9%94%81"><span class="nav-text">Lock锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">高并发及线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-text">多线程的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">多线程的安全性问题</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
